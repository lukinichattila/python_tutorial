   
!!!- pythontutor.com
   - 2 types of languages: - interpreted and compiled
     - c, C++ <- compiled
	 - python, java, javascript <- interpreted
   - for finding version: python -v
   - python interpreter is a virtual maschine just like java
   - name convention is a script is a program for an interpreted language
   - one file in a multifile python program is a masterscript that is an entry in the python program(usually main.py but can be any)
   - a python file is level 1 compiled that results in bytecode( *.pyc). The python virtual maschine compiles to maschine code (compilation level 2) that is 
     executed on the processor.C and C++ does not have level 2 compilation that is why is faster then interpreted languages that are 2 level compiled
   - the virtual maschine verifies if a function is called multiple times and caches the maschine code so that it not needs to reintepret it when the 
     function is called again (python does not have this feature, java does(pypy.org python with cache))
   - interpreted languages can change code at runtime, compiled languages not
   - virtual maschine helps achieve platform independence
   - There are utilities that help construct executable programs from python scripts.after compilation makes them platform dependent:
   Ex. py2exe, pyinstaller, py2app, freeze, cx_freeze
   - Jython produces code that runs on Java virtual maschine but can read python code
   - Iron Python can run C# and python scripts together
   - Stackless (not concurent programming - not secvential)
   - in python, identetion is crucial, it makes sense what  comes in which code block. it has 4 space
   - we can write multiple line of code on a single line with ; between them:
   Ex.  l=15;print(l)
   - ASCII - 128 characters
   - UTF-8 standard holds all the language characters for any language(japan, arab,chinese)(used by html, xml,etc)

command line arguments:
---------------------------------------------------------
   - we can use command line arguments with files from sys library:
   ex. import sys                                                      <- acces to command line arguments through sys module
       print (sys.argv)                                                <- the arguments we gave to the .py files in comand line
	   cmd line->python myprogy.py abc 123 "a fost odata"
	   ['myprogy.py','abc','123','a fost odata']                 <- list with all the strings separated by space from the command line arguments
	- sys.argv[0]    - file name 
	- sys.argv[1]    - 'abc'
	- to check if there was an argument given:
	ex. if len(sys.argv)>1
	       print('we have an argument!")
		myargument=argv[1]
    ex. try:
	      myargument=argv[1]
		except:
		   print("we have no arguments!"
		   exit()
	- we can read all the arguments after the filename
	ex. for filename in sys.argv[1:]:   <- all the arguments after the filename

modules in python:
---------------------------------------------------------
   - modules are *.py scriptfile
   - modules are searched in "sys.path" - it is a list of paths where python library files are located and the current directory
   - PYTHONPATH - environment variable in windows
   
   - we can insert a new path folder in sys.path:
   ex. sys.path.insert(0,'c:/myscript')                  <- sys.path is a list where we can insert elements 
   
   - modules means a file with functions and classes for reuses, package means a group of files, module names start with  lowercase 
   - we can import a *.py file with import
   ex. import hangman
       x=hangman.use()
   
   - we can import a module as an alias and use the alias in front of the functions:
   ex. import hangman as hg                <- hg is an alias for hangman
       a=hg.use()
   
   - we can import just parts of the module with the from keyword - we import just the list:
   ex. happy.py has the folowing variable and function: 
       def greeting():
			print ("Hello")
	   person1=[1,2,3,4]
	   in main.py we have :
	   from happy import person1     <- a list  
	   print(person1[0])          <- when importing with from we dont use the modulename when we adress the variable(not happy.person1[age])
	   
   - we can import more things when we import a module:
   ex. from happy import person1 , greeting             person1 is a function, greetig is a variable, if we specify what to import then we dont need to specify 
                                                        library name:
       a=person1(greeting)
   ex. from importable import person as ps
   ex. from importable import (object1,object2)
   ex. from importable import *  
   
   - if we have a file in a subdirectory "librar" we can import it with directoryname.libraryname
   ex. import librar.filename
   
   - we acces something from the library with the libraryfilename.functionname() or libraryfilename.variablename if we didnt import with from lib import variable,func,class
   - we acces somethin from the library with funcname, variable (without libraryname in front) if we import it with "from library import funcname, variable" 
   - when we import something in python, the interpreter executes and creates those elements that we import

packages:
---------------------------------------------------------
   - packages are collection of *.py scriptfiles
   - There are many packages on PyPi.org
   - packages are installed with the pip utility 
   ex. pip command optional
       pip list --outdated
	   pip install <package> --upgrade
	   pip install matplotlib --upgrade
   - tool to manage imported package  http://pypi.org - e repository of 400k open source libraries (search projects)
   - a package is a directory with modules with a file __init__.py
   ex. if we have in a dir Bmp.py, jpeg.py
       use: import Graphics.Bmp
	        image=Graphics.Bmp.load(
   ex. import numpy as np
       numpy.
   
   - if we want to make a package, we create  a folder and inside we need to have __init__.py file.that tells python that it is a package and it is more .py files in it
     it not needs to contain any line of code, could have just a comment in it with #comment  .the folder can contain subfolders and those  need the __init__.py
   - if we want to import a file from a package subfolder we import it with :
   Ex. from MyMainPackage.Subfolder import mymodule        <- mymodule = mymodule.py, MymainPackage contain a folder Subfolder that has the __init__.py and mymodule.py   
	   a = mymodule.myfunction()                 <- we call the function from the file
   - we can check in a file that we imported it to other .py files or we run the file directly with >python filename.py.
	Ex. if __name__ == "__main__":                   <- if python runs a file directly it assigns the __name__ property the "__main__" string
			#execute code that runs just when the .py file is not imported (like a main())
 Commenting :
---------------------------------------------------------
   - comenting a line starts with #
   # this is a comment
   - we can document the code with """ This class or function does xyz""" under the class name <- when we hover with the mouse over the class name it will display this description

!!!To execute a python program:
----------------------------------------------------------
   - in the command prompt:
   Ex. python main.py                         <- .py is the source code

sleep in python:
----------------------------------------------------------
   - we can have a pause in our program with the sleep function:
   ex. import time
       time.sleep(1)                   <-  stops execution for 1 second
print
----------------------------------------------------------
   Ex. print("casa", 23,32.4)   <- we can use multiple variables separated with ,
       print("Hello 'moni' dear")
   - we can write text multiple lines with \n in the text:
   ex. print("Hello world\nHello world\nhelloworld")                                  <- prints to 3 different line
       l=[2,3,4,2]
	   print(f'nrin ordine={lista}')                                                  <- fstring
   - we can have multiline prints:
     print('''
	    Meniu stringuri:
		1. citeste
		2. scrie''')
   - we can clear the output window:
   ex. from replit import clear
       clear()  
input
----------------------------------------------------------
   - input always results in a string
   - we can enter an object with the input ('message to print')
   Ex. line=input("what is your name?")
       print('Hello',line)
   Ex. print("Helle "+input("what is your name?")) 
   
data types in python and variables
-----------------------------------------------------------
	- function and type names are not reserved words, we can accidentaly override them
	- variable names start with small letters
	- variables are created on the heap
!!!	- every data type is an object in python
    - variables do not need declared with their data type
	- variables come in existence when they are assigned a value, they not need to be declared
	- variables contain a reference to the object they point to (they dont make a copy!!!!!
	- variables can store data of different types	
    - in Python if a variable starts with Big letter, it is considered constant (it is not)
    ex. Number=23	
    - python has the following data types:
        text type: str  
        numeric types: int, float complex
        sequence types: list, tuple, range
        mapping type: dict
        set types: set, frozenset
        boolean types: bool
        binary types: bytes, bytearray, memoryview
	- int  : 5,3,-7                       <- positive or negative numbers, arbitrary large, 0 is the default, without decimals of unlimited length
	- we can represent 123456 as 123_456     <- python knows that _ is for helping us understand large numbers
	- bool : True, False                  <- default is False
	
	- float : 3.141592 (double in c/C++)  <- positive or negative float number, arbitrary large
	Ex. x=3.14
	    x=12E4                            <- scientific notation e power of 10
		
    - complex : complex numbers are writen with a "j" as the imaginary part
	Ex. x=3+5j
	    y=5j
		
	- str 'man', "girl"                   <- strings have default "" empty string
	- Lists
	- user (object data types)
	
!!!	- we can predefine a data type to a variable :
	ex. a:int                <- a will be int, python gives error if assigned differnet type of data type
	
	- type(): we can find the type the data of a variable with the type(var)
	Ex. print(type('type'), type(3))               <- class'str' class 'int'

    - we can check if a variable is an int:
    Ex. a = "ert"
        if type(a) == int:
        if a.isdigit() == True:
		
    Ex. if isinstance("This is a string",str):
	
	- variables are asigned values:
	Ex. x=0                     <- x assigned an integer object
	    y='erte'                <- y assigned a string object
	    z=True                  <- z assigned a boolean object
	    print(x,y)
		
   - variable names are not tied to their object type:
   Ex. x=2
       x='trete'    <- x can point to different data type after it was assigned a different data type initialy, 
	   
   - data values that are not pointed to by variables will be destroyed
   Ex. x=2
       x='trete'    <- 2 will be destroyed by garbage collector, no variable points to it
	   y=x          <- values in x will be copied to y
	   
   - we can assign multiple variables multiple values:
   Ex. x,y,z="Luki", "atti", "feri"                 <- multiple definition of variables
   ex. x,y=y,x                                      <- swap numbers
   	   
	- we can convert from float to int:
    Ex. z=23.4
        y=int(z)
		
    - we can convert from int to complex:
	Ex. x=45
	    y=complex(x)
		
    - type(): we can find out the type of a variable:
    Ex. print(type(y))
	
	- we can have a variable not initialized with None:
	b = None
	
	- hex() - we can find the hexa value of a number.returns a string
	a = hex(12)             <- "0xc"      x means hexa
	
	- bin () - we can find the binary representation of a number.returns a string:
	ex. a = bine (1234)    <- 0b100010101   b means binary
	
	- pow() - we can raise a value to power n:
	ex. a = pow (2,4)         <- 2^4
	
	- abs() - we can find the absolute value of a number:
	ex. a = abs (-3)        <- 3
	
	- round() - we can round  numbers
	ex. a = round (3.14354567, 2)              <- 3.14       
	
	

python dynamic typing:
--------------------------------------------------------------
   - dynamic typing means that after we asssigned a data type to a vaiable, we can assign a different one later:
   ex. a = 5
       print (a)
	   a="text"
	   print (text)
	   
variable scope:
--------------------------------------------------------------
   - variables declared in upper function hierarchyies are visible in lower functions
   - variables declared  in lower function hierarchies are not visible in upper functions
   - in python there is no such thing as block scope
   - if a variable is declared anywhere in a function then it gets function scope 
   - if a variable in a lower hierarchy are declared with the same name with a variable in an upper function , it will overshadow the upper hierarchy variable
   - if we want to use a variable declared in the upper hierarchy we need to declare with global varname     <- not recomended
   - global constants are variable that we declare once and never modify.We declare it with big letters
   ex. PI=3.14
       URL="http:google.com"
   
randomization  in python:
--------------------------------------------------------------
   - random.randint(): we can generate random numbers:           <- we need to import the library
	Ex. import random                           <- imports random module
        n=random.randint(0,22)		            <- generate random numbers between 0 an 22 included
   - random(): we can generate a random number with random() function:
   ex. n=random.random(0,1)                     <- generate a random floatig point number between 0 and 1
   
   - random.choice(): we can return a random element from a list:
   ex. import random
		list=["asda","dfgD","ert"]
		random.choice(mylist)
	
	- random.choices(): - we can generate a list of random items with choices
	ex. list=["asda","dfgD","ert"]
	    rand-list_elements = random.choices(list,2)                  <- ["asda","ert"] selects 2 random elements from the list and returns a list
		
   - shuffle(): we can randomly reorganiza a list with shuffle() method.it shuffles the lists items, does not return a new list:
   ex. import random                     <- from random import shuffle  #works too
		list=["asda","dfgD","ert"]
		random.shuffle(mylist) 
   
   - we can use different seed to generate random numbers:
   ex. import random
       random.seed(101)                      <- get different list of random numbers.if we reset the seed to the same seed the list will give the same sequence of random numbers
       random.randint(0,100) 
   
   - random.sample() - we can select random unique elements from a list, so when an element is taken out it will not be generated again when randomized again 	
   ex. list=["asda","dfgD","ert"]
       n = random.sample(list, 2)              <- generates a list of 2 random elements frokm "list" that will be not drawn again if we randomize the list again 

   - random.uniform() - we can generate random floating values that have the same chance of beeing drawn when randoms are generated:
   ex. a = random.uniform(a=0,b=100)          <- generates from from 0 to 100
   
Debugger in python:
----------------------------------------------------------
   - we can import with the pdb module the debugger module
   ex. pdb.set_trace()                 <- the program will stop at this line and we can start the debugging
   
strings in python:
----------------------------------------------------------
   - strings are inmutable meaning  we can read the string char by char however we cant change the elements value with string[pos]="c"
   - if we dont have ' in line we can use :
   Ex. print('world')
   
   - we can concatanate strings in python with +
   Ex. first="Luki"
       second="Atti"
       print(first+second)
	   
   - we can use escape caracters in strings and prints:
   Ex. print("This is \ta good \nday")
	   
   - we can step slice a string:
   ex. print(s[0:4:2])    <- prints "hl"
       print(s[0::2])     <- prints "hla"
   
   - we can backwardslice a string:
   ex. print(s[4::-1])       <- prints "anloh"
       print([:-4:-1])       <- prints "loh"    

   - we can use string operators:
   ex. print("Hello"*5)          <- prints  hello hello hello hello hello

   - we can have string replacement fields:
   ex. a="{x}/{y}".format(x=100,y=100)     <- switches x and y with 100 and 100
   ex. print("my age is {0} year and {1} month".format(age, month)}
   ex. print("Nr is {0:2} and squared {1:2}.format(2, 3))            <- :2 with 2 wide
   ex. print("Nr is {0:<2} and squared {1:<2}.format(2, 3))          <- left alligned
   ex. print("Nr is {0:^2} and squared {1:^2}.format(2, 3))          <- center alligned
   ex. print("pi is {0:12.20f}".format(22/7))                             
   
   - ord() - we can find the ASCII character code of a character:
   ex. a=ord('a') 

   - chr() - we can convert ASCII code to characters:
   ex. print(chr(120))            <- "x"
   
   - if we have a ' in the string we can use the ""
   Ex. print("Worl'd")
   
   - we can have a multiline string:
   ex. s=''' This
             is
			 Sparta '''
	ex. s="""  ez a szoveg
        tobb sorba van irva""" 
			 
   - if we enter 'enter' when input a string, enter is empty string ''
   ex. l=input("enter enter")
       if l=="":
   
   - fstring: we can mix  numbers with strings with the fstring:
   ex. l=f"your score is {var:2}"                                     <- returns a string, var:2
   
   - format - we can format a float number into string:
   ex. amount = "{:.2f}".format(stringvar)                            <- float to string with 2 decmal precision
   
   - os.path.isdir(): we can check if a string is a directory's name or not:
   Ex. import os
       if os.path.isdir(stringname)
   
   - in: if we want to find if a string in another string we have the in:
   ex. s="eterterte"
       if("er" in s)
	       print("am gasit stringul")
   
   - not in: we can check if a string is not in another string:
   ex. s="eterterte"
       if("er" not in s)
	       print("nu am gasit stringul") 
   
   - len(): we can check the nr of characters in a string with len()
   ex. l=len(stringvar)
   
   - sys.getsizeof(): we can find out the length in bytes of a string with sys.getsizeof()
   ex. import sys
       l=sys.getsizeof(stringvar)
   
   - we can return the elements in a string:
   ex. print("Hello"[0])                         <- H
   
   - lower(): we can change the letters in a string to lowercase with the .lower() function:
   ex. l="sdfere"
       result=l.lower()                                                <- returns a new list with all the letters lowercase leaving the original string intact
	   
   - upper(): we can change the letters in a string to uppercase with the .upper() function:
   ex. l="sDfere"
       result=l.upper()                                                <- <- returns a new list with all the letters uppercase leaving the original string intact

   - swapcase(): we can change the letters from lowercase to uppercase and from uppercase to lowercase with the .swapcase() function
   ex. l="sDfere"
       result=l.swapcase()   
	
   - count(): we can count the number a letter apears in a string:
   ex. l="sDfere"
       print(l.count("e")	   
   ex. l="sDfere"
       print(l.count("e",2)    <- counts from index 2 to the end of the string
   ex. l="sDfere"
       print(l.count("e",2,4)    <- counts from index 2 to index 4 of the string
   
   - strip(""): we can remove spaces or other characters from the begining and end of the string with the strip() function.it returns a copy of the string:
   ex. l=" sDfere "
       x=l.strip()     <- removes whitespace
	   x=l.strip("D")  <- remove "D"
   
   - capitalize(): we can change in a string the first letter to uppercase and the rest to lowercase 
   ex. l="sDfere"
       x=l.capitalize()
   
   - find(): we can find the first occurence of a string in a string with the find() method.it returns the index where it finds it or -1 if not:
   ex. l="sDfere"
       x=l.find('fe')
   ex. l="sDfere"
       x=l.find('fe',2)           <- will return the index of the string searched after index 2
	   
   - isalnum(): we can find if a string has only alfanumeric values with isalnum()
   ex. print(l.isalnum())      <- True or False
   
   - isnumeric(): we can find if a string has only numeric values with isnumeric()
   ex. print(l.isnumeric())      <- True or False
   
   - isalpha(): we can find if in a string is alfabets with the isalpha() method:
   ex. l="sDfere"
       print(l.isalpha())      <- True or False 
	   
   - isdecimal(): we can find if in a string is just decimal values with  isdecimal() method:
   ex. l="sDfere"
       print(l.isdecimal())      <- True or False
	   
   - isdigit(): we can find if in a string is just digits values with  isdigit() method:
   ex. l="sDfere"
       print(l.isdigit())      <- True or False

   - islower(): we can check if a string has all the letters with lowercase with .islower() method:
   ex. l="sDfere"
   print(l.islower())
   
   - isupper(): we can check if a string has all the letters with upercase with .isupper() method:
   ex. l="sDfere"
   print(l.isupper())
   
   - isspace() - we can find out if a string has just spaces in it
   ex. l="sDfe re"
       a = l.isspace()                      <- False
	   
   - istitle() - we can find out if a string have the title formating - first letter big?
   ex. a = l.istitle()
   
   - join(): we can join the elements of an iterable with character(or string?) between elements with .join() function
   ex. text = ['Python', 'is', 'a', 'fun', 'programming', 'language']
       print(' '.join(text))                                    <- Python is a fun programming language
 
   - translate(): returns a string where some specified characters are replaced with the character described in a dictionary, or in a mapping table:
   ex. l="sDfere"
       table = l.maketrans("s", "K")
       l.translate(table)               <- table contains the mapping of the character that i will be changed with a character ->KDfere
	   
   - replace(): we can replace a string with an other string with the replace() function:
   ex. l="sDfere"
       replacedtext=l.replace("s", "p")           <- pDfere
   ex. l="sDferestres"
       replacedtext=l.replace("s", "p",2)           <- replaces "s" 2 times with p
	   
   - rfind(): we can find the highest index of the substring in a string. if found, returns index, if not then -1
   ex. l="sDfere"
       str.rfind("sD")

   - rindex(): we can find the highest index  of the substring inside the string . if the substring is not found then exception:
   ex. quote = 'Do small things with great love'
       print(quote.rindex('o small ', 6, 20))	   <- 
   
   - index(): we can find an elements position in the list (first appearence) with the index() function:
     listname.index(value,startelement,finishelement).If element not found then returns ValueError
   ex. l=[1,2,3,4,5,6,7,8]
       a=l.index(3)                             <- 2
     

   - split(): we can split a string in a list of strings , with a separator .split():
   ex. text = 'Python is a fun programming language'
       print(text.split(' '))                                 <- ['Python', 'is', 'a', 'fun', 'programming', 'language']

   - rsplit(): we can split string from the right at the specified separator and returns a list of strings with rsplit().
   ex. text= 'Love thy neighbor'
       print(text.rsplit(". ,"))
	   
   - startswith(): we can check if a strings start with a string with the startswith() method:
   ex. message = 'Python is fun'
       print(message.startswith('Python'))
   ex. message = 'Python is fun'
       print(message.startswith(('Python','is'))               <- searches if the string starts with any element from a tuple
   
   - endsswith(): we can check if a strings ends with a string with the endsswith() method:   
   ex. print(newstring.endswith("string")) 
   
   - partition() - we can partition a string after a separator.String is split to a list, first element is before the separator, element 1 is separator, 
                   element 2 after separator.It does for the first occurence of separator, rest ignore.if separarator not found then return 2x empty string and separator in a tuple:
   ex. s = "Holnap megyek haza"
       a = s.partition(" ")                  <- ("Holnap"," ", "megyek haza")
   
   - title() we can make each word in a string start with uppercase with the title() function:
   ex. text = 'My favorite number is 25.'
       print(text.title())
	   
   - we can add punctuations, digits, whitespaces to a string:
   ex. import string 
       strip=string.whitespace+string.punctuation+string+"\"."

   - a string can be rawstring  - it does not reat /n and other special characters like special:
   ex. b_string=r"this is a \n a string split \t \t ND TABBED"
   
   - we can iterate through the letters in a string:
   ex. for i in "stretet":
       print (i)
	   
   - center() - we can wrap the string around with an other string:
   s= "hello"
   s.center(20,"z")          "zzzzzzzhellozzzzzzzz"    - string length 20, put before and after string
   
string slicing:
------------------------------------------------------------
   ex. s="abcdefghijklmnopqrstvuwxyz"
       print(s[3])     <- d
	   print(s[-1])    <- z
	   print(s[3:10])	<- defghij     <- range of elements
	   print(s[:9])     <- abcdefghij
	   print(s[1:])     <- bcd....
	   print(s[1:7:2])  <- bdf   <- range with steep
	   print(s[::-1])    <- reverse iterator from begining to end

REGEX or regular expressions in python:
------------------------------------------------------------
   - search() we can search for a pattern in a string, returns just the first occurence of the pattern:
   ex. import re
       test = "the phone is not home.I lost the phone"
	   pattern = r"phone"                     <- r means it is raw string literal, interprets escape characters as are
	   re.search(pattern, test)               <- searches for regex pattern in the test string, returns just the first occurence
	   
	- findall()we can search for all ocurences of the regex pattern in a string, returns a list with all the occurences
    ex. import re
        test = "the phone is not home.I lost the phone"
        pattern = r"phone"                       <- r means it is raw string literal, interprets escape characters as are
		mylist = re.findall(pattern, test)       <- ["phone","phone"]
	
    - finditer() - we can find the pattern in an iterable.it returns an iterable:
    ex. import re
	    test = "the phone is not home.I lost the phone"
        pattern = r"phone"                       <- r means it is raw string literal, interprets escape characters as are
        for a in re.finditer(pattern, test):
           print (a.group())		
	   
	- span :we can find the start and end position of a substring in a string
	ex. import re
	    test = "the phone is not home.I lost the phone"
		pattern = r"phone"                     <- r means it is raw string literal, interprets escape characters as are
		match = re.search(pattern, test)       <- the result is stored in an object
		if (match):
		    print(match.span())                <- we aply the span method on the match object to find the start and end indices of the match
	
	- group() - we can find the regex that matched the pattern. it returns a string
	ex. import re
	    test = "the phone is not home.I lost the phone"
		pattern = r"phone"                     <- r means it is raw string literal, interprets escape characters as are
		a = re.search(pattern,test)
		a.group()                     <- "phone"
		
	- .sub(pattern,repl,string,count) - we can return a string with replaced values
    ex. s = "i am human beeing"
	    res1 = re.sub("a","x",s)     <- i xm humxn beeing
		res2 = re.sub('[a,i] ,"x",s)  <- x xm humxn beeing
	
	- () we can group together regex expressions with ()
    ex. import re
        test = "the phone is not home.I lost the phone.Phone nr is 323-432-345"
        patern = r"\d{3}-\d{3}-\d{3}"
		groupedpattern = r"(\d{3})-(\d{3})-(\d{3})"
        find = re.search(pattern,test)             <- gives the whole number
        find = re.search(groupedpattern, tst)		<- group(1) = 323, group(2) = 432
	
	- compile()   compile a regular expression pattern into a regular expression object.can then be used to perform matching operations on text.
	ex.  import re
        test = "the phone is not home.I lost the phone.Phone nr is 323-432-345"
        patern = re.compile(r"(\d{3})-(\d{3})-(\d{3})")
		result = re.search(patern, test)
		print(result.group())            <- 323-432-345    same as group(0)
		print(result.group(1))           <- 323
		print(result.group(3))           <- 345
	
	Regex patterns:
	- special characters like ( or ) can be used in regex with a \ in front like \(
	\d    - a digit          (0-9)
	\w    - alfanumeric      (A-Z, a-z,0-9, "_")
	\s    - white space             " "
	\D    - non digit               not [0-9]
	\W    - non-alfanumeric         not (A-Z, a-z,0-9, "_")
	\S    - non-whitespace          not " "
	\t    - tab
	\n    - matches newline
	\r    - matches return
	\b    - matches only the begining or end of the word
	.     - matches any single character except newline
	+     - preceeding character ocurs one or more time           Vers 1_1          Vers \w+         +comes after the eleemnt to search
	-     - used for range of characters                          [0-9], [a-d]
	{3}   - preceeding character ocurs 3 times                    abc               \D{3}
	{2,4} - preceeding character occurs 2 or 4 times              abc                \d{2,4}
	{3,}  - preceeding character occurs 3 or more                 abc               \d(3,)
	*     - preceeding character occurs 0 or more times           AAACC             A*B*C*
    ?     - preceeding character apears once or None              plurals?          plural
	^     - folowing stringpattern  is begining of a string       Eat me Billy      r"^Eat.*"     <- begins with Eat
	$     - preceeding stringpattern matches end of string        Where is my Cake  r"Cake$"      <- ends with Cake
	[]    - find sub group() inside group()  that satisfy what is inside the bracket  
	()    - group options inside the colons                       caterpillar,catfish    r"cat(fish|nap|erpillar)"
	[abc] - matches a or b or c     
	[a-zA-Z0-9] - matches any letter or number
	[^are] - exclude are from the search
	[^.?!]+ - excludes .!? from the string no matter how many times apear
	[\w]+-[\w]+  - finds all the words that have - in midle like hypen-words
	"^if.*if.*$" - matches a string that begins with an if and then has somewhere in it an other if	
	^if(?=(.*if){2}).*$ - matches a string that begins with an if and in it there is 2 more if
	
	
	   
conversions:
------------------------------------------------------------
   - we can convert one type to another with they type(variablename)
   Ex. varsta=input("ce varsta ai?")
       b=int(varsta)                     <- converts string to int
	
   - if cannot make conversion then exception "qq" to int exception 
   ex. inercari=10
       msg=f'Ai epuizat toate cele{incercari} incercari'	         <- with f' we convert from int to string
       msg=f'Ai epuizat toate cele{incercari:<20} incercari'         left align with 20 character total (blank if nothing)
   
   - we can convert from int to string:
   ex.l=str(stringvar)
   
   - round(): we can round a float number ( round it to the closest integer)
   ex. s=round(2.342)                <- 2
   
   - we can round it  to decimal places:
   ex. s=round(2.342:2)                        <- 2.34
   
   - if we want to get rid of the decimals in a division we can use //
   ex. s=8//3
   
variable scope:
----------------------------------------------------------
   - variables created outside any function is a global variable
   - global variables can be used inside or outside functions by everyone
   - to change the value of a global variable inside a function we can with the global keyword
   Ex. 
       x=1
	   def func():
          global x                             <- if we dont declare that x refers to the global variable it will create a local variable with name x
		  x=10
		  print (x)
	   func() 

if else:
-----------------------------------------------------------
  - in python the if condition has if - elif - else
  Ex. if rez=="9":                 <- if(rez=="9") works also
        print ('bravo!')
      else:
        print('not 9')	
   Ex. varsta=input("how old are you")
       if int(varsta)<18:                     <- conversion needed because input inputs only string
           print("you are underage")
       else:
           print("you are overaged")	   
   ex. if age<=1:
        print ("age is <=1")
	   elif age==10:
		print("age is 10")
	   elif age==12:
		print("age is 12")
	   else:
	    print ("age not known")
   Ex. numar =4
       if numar >0
          print("nr este poz")
       else:
         if numar<0:
            print("nr este negatic")
     	 else:
            print ("nr este 0")	
   Ex: numar =4
       if numar >0
          print("nr este poz")
       elif numar<0:
            print("nr este negatic")
       else:
            print ("nr este 0")

ternary operator:
------------------------------------------------------------
    - it is a shortened if else:
    ex: x = 10
        y = 5
        max_value = x if x>y else y
		
python operators:
------------------------------------------------------------
   - in python the operators are divided in 7 groups
      - arithmetic operators  
	  - assignment operators
	  - comparison operators
	  - logical operators
	  - identity operators
	  - membership operators
	  - bitwise operators
   - Arithmetic operators:
     + - addition - x+y
	 - - subtraction - x-y
	 * - multiplication - x*y
	 / - division - x/y
	 % - modulus - x%y
	 ** - exponential - x**you
	 ** - square root - 100 ** 0.5
	 // - floor division  x//you
   - Assignment operators:
     = - equal - x=5
     += - plus equal - x=x+5
     -= - minus equal - x=x-5
     *= - multiply equal - x=x*5
     /= - division equal - x=x/5
     %= - modulus equal - x=x%3
     //= - floor division equal - x=x//3
     **= - exponential equal - x=x**3
     &= - and equal - x=x&3
     |= - or equal - x=x|3	
   - comparison operators  
     == - equal - x==y
     != - not equal x!=y
	 >,< - greater then, less then - x>y, x<y
	 >= - greater or equal - x>=y
	 <= - less then equal - x<=y
   - logical operators:
     and - true if both are true, else false - x<5 and y<6
	 ex. if a and b
	 or - true if one is true, else false - x<4 or y>3
	 not - true if not - not (x<5 and y<10)
	 ex. if not boolean
   - identity operators
     is - return true if both variables are of same object - x is you
     is not - returns true if both the variables are not the same object - x is not y
     	 
   - membership operator:
     in - returns true if a sequence with the specified value is present in the object - x in y
     not in - returns true if a sequence with a secified value is not present in the object - x not in y
	 Ex. x=["apple","orange"]
	     print("banana" in x)   <- false
		 print("banana" not in x) <- true
   - bitwise operators:
     & - AND - sets each bit to one if both bits are 1
	 ex. c=a&b            <- operator copies a bit to the result if exists in both operands
     | - OR - sets each bit to 1 if one of the bits are 1
	 ex. c=a|b            <- operator copies a bit to the result if exists in in one operands
     ^ - XOR - sets each bit to 1 if only one of the bits is 1
	 ex. c=a^b            <- operator copies a bit to the result if exists in  one and only one operands
     ~ - NOT - invert all bits
	 ex. c=a~b            <- operator copies a bit to the result if exists in  one and only one operands
     << - zero fill left shift - shifts left by pushing zeros in from the right and let the leftmost bits fall of
	 ex. c<<2             <- left shifts with 00000011
     >> - signed right shift - shift right by pushing copies of the leftmost bit in from the left, and let the rightmost bits fall of
	 ex. c=a>>2           <- a is right shifterd with 00000011
	 ~ - complements - reverses the bits 
	 ex. c=~a         <- makes 1 in 0 an 0 in 1

while loop:
-----------------------------------------------------------------
   - executes a block while it is true:
   while cond:
     -code block-
   Ex. suma=0
       nr=1 
       while nr<=1000
         suma+=nr
	     nr+=1
	   print(suma) 

   Ex. suma=0
       nr=1 
       while True
         if nr>1000:
          break	 
         if nr%5==0
           continue
         suma+=nr
         nr+=1
	   print(suma)
	
	- we can have an else: after the while executes it will execute what is in the else:
	ex. while nr<=1000
         suma+=nr
	     nr+=1
	   print(suma) 
	    else:
          return suma	
   - we can use break and continue with while:
    while a<10:
     if a==3:
        continue
     else:
        break	 

for loop:
------------------------------------------------------------------
   - executes a block multiple times
   ex.l=["Atti","Tibi","Shivan","Gauron","Feri"] 
      for element in l:
       print(element)
	   if(cond)
	      break
	   
   ex: for idx in range(len(l)):                                   <- default =0 to len(l)-1     
          print(l[idx])          <- c style array acces notation
   ex. for contor, element in enumerate(list,1):                       <- we have 2 variable incrementing :contor from 0 to n-1, element l[0],l[1],l[2]...l[n-1]
         print(f"{contor:3}. {element}")
   
   - we can loop through a range of numbers:
   ex. for x in range(5):                                            <- by default a range starts from 0 to 5(5 not included)
   ex. for x in range(2,6):                                          <- values 2-5
   ex. for x in range(2,6,3):                                        <- values between 2 and 5 with step of 3
   
   - we can execute code after the for is ended with else::
   ex. for x in range(2,6,3):
			x+=1
	   else:
	      print("hello!")
   
   - we can iterate through a collection with enumerate:
   ex. for count , value in enumerate(list)                        <- count is a counter , and value is the value one at a time from the list
   
   - we can specify a start argument for the enumerate:
   ex. for count , value in enumerate(list, start=3)               <- starts from the 4th element
   
   - we can use continue or break to get out of a loop or restart iteretation with next element:
   ex. for i in a:
         if i==mango:
		    continue
		  else:
		    break
			
   - we can have an empty for loop.we need the pass keyword:
     ex. for a in range:
	        pass
colections:
-----------------------------------------------------------
   - an object with objects
   - elements cant be different type once they are set with a type
   - lists:
      - ordered collection
	  - slow search
   - multimi:
      - unic elements
	  - speed
   - maps:
    - key - value pairs
    - speed
    - unnique keys
   - list - mutable/unmutable	   

python lists:
----------------------------------------------------------
   - list is a collection which is ordered, changeable and allow duplicates elements
   - allows duplicate membership
   - list indices start from 0
   - we can insert different datatypes in it
   ex: l=["edre",1,True,"Erd",3]
   
   - we can point to the same list in memory
   ex. list1=list2                     <- shallow copy
   
   - we can have a copy of a list (diferent memory region):
   ex. list2=list(list1)               <- produce a new list in memory 

   - copy(): we can have a different list, we can do it with copy:
   ex.import copy 
      list2=copy.deepcopy(list)   

   - the list is created placing all the elements inside [ ] separated by commas.first element is always 0
   Ex. list1=["Toni","Zoli","Tibi"]
       print(list[0])     -> "Toni"
	   print(list[1])     -> "Zoli"
	   
   - we can have negative indexing. element [-1] is the last element of the list, [-2] is the before last element
   ex. print(list[-1])   <- "Tibi"
   
   - we can have list with lists:
   Ex. l=[4,'casa',True, [33,12],0]
   
   
range of indexes - list slicing (
----------------------------------------------------------
   - we can specify a range of indexes by specifying where to start and where to end the range
!!!- when specifying a range, the return value will be a new list with the specified items
   - the end range element=end range-1
   ex. list1=["Atti","Tibi","Shivan","Gauron","Feri"]
       print(list1[1:3])                        <- Tibi Shivan  - element 3 not included
   
   - we can specify elements from begining to a set number:
   ex. list1=["Atti","Tibi","Shivan","Gauron","Feri"]
	   print(list1[:3])                                 <- Atti Tibi Shivan <- element 3 not including
	
   - we can specify all the elements from 1 to end:
   ex. list1=["Atti","Tibi","Shivan","Gauron","Feri"]
       print(list1[1:])                                 <- Tibi Shivan Gauron Feri
   
   - we can view elements with negative indexes:
    ex. list1=["Atti","Tibi","Shivan","Gauron","Feri"]
	    print(list[-1:-3])
	  
   - we can specify a range with steps:
    ex. list1=["Atti","Tibi","Shivan","Gauron","Feri"]
	    print(list[1:4:2])     <- Tibi, gauron
		
   - we can have backward list:
   ex. list1=["Atti","Tibi","Shivan","Gauron","Feri"]
       print(list[::-1])            <-  Feri Gauron Shivan Tibi Atti

   - we can specify a range in the for loop with slicing:
   ex. for i in list[1:]:
           print (i)
		   
   - we can make a list with range:
   ex. print(list(range(2,10))        <- makes a list and prints 2,3,..10 
   
   - we can compare 2 ranges:
   ex. range1=range(1,10,2)
	   range2=range(1,10,2)
	   print(range==range2)           <- prints true
	   
   - 

iterators:
----------------------------------------------------------
   ex. string="1234567890"
         my_iterator=iter(string)
         print(next(my_iterator))                    / prints 1
         print(next(my_iterator))                    /prints 2
         for char in iter(string)                     /prints 1 2 3 4 5 6 7 8 9 for char in string   <- implicit iterator in the background
             print (char)
	ex. my_string=["a","b","c","d","e","f","g"]
        iteratorom=iter(my_string)
        for i in range (0, len(my_string)):
            print(next(iteratorom))                            /prints: a b  d e f g
			
working with lists:
----------------------------------------------------------	   
   - we can change the element in the list at a certain position:
   ex. list1=["Atti","Tibi","Shivan","Gauron","Feri"]
       list[1]="Teri"
   
   - for: we can loop through a list with a for loop:
   ex. for i in list1:
          print(i)

   - check if name exists in list with in:
   ex. list1=["Atti","Tibi","Shivan","Gauron","Feri"]
       if "Tibi" in list:
	      print("Tibi is in the list")
	   else:
	      print("Tibi is not in the list!")
		  
   - sum() we can have the sum of the collection with the sum() function:
   ex. a=sum(iterable, start)
   
   - len(): we can check the length of a list with :
   ex. list1=["Atti","Tibi","Shivan","Gauron","Feri"]
       print (len(list1))
	   
   - append(): we can add a new element to a list with append.we can add a new list but then the list will be an element in the list (list in list).see extend:
   ex. list1=["Atti","Tibi","Shivan","Gauron","Feri"]
       list1.append("Kati")                               <- adds an element to the end of a list
   
   - insert(): we can insert an element to a specified index position with :
   ex. list1=["Atti","Tibi","Shivan","Gauron","Feri"]
       list1.insert(2,"Kati")                             <- "kati" is inserted at postion 2 and all the rest of the elements are moving to the right(index pos also)
	   
   - remove(): we can remove the first occurence of an element by name from the list with :
   ex. list1=["Atti","Tibi","Shivan","Gauron","Feri"]
       list.remove("Tibi")                                <- removes "Tibi" from the list
	   
   - pop(): we can remove the last element from the list with :
   ex. list1=["Atti","Tibi","Shivan","Gauron","Feri"]
       list1.pop()
	   
   - del(): we can delete a list or remove a certain element in a position with :
   ex. list1=["Atti","Tibi","Shivan","Gauron","Feri"]
       del(list1[2])                                       <- removes element 2 of the list
	   del list1[2]	   
	   del(list1)                                          <- deletes list1
	   
   - clear(): we can clear all the elements from a list with :
   ex. list1=["Atti","Tibi","Shivan","Gauron","Feri"]
       list1.clear()                                       <- he list becomes empty
	   
   - copy(): we can make a copy of a list with :
   ex. list1=["Atti","Tibi","Shivan","Gauron","Feri"] 
       list2.copy(list1)                                   <- list 2 will have the elements of list1

   - extend(): we can extend our list (add an other lists elements to the lists end, (unique elements)) with the :
   ex. list1=["Atti","Tibi","Shivan","Gauron","Feri"]
       list2=["1","2","3"]
       list1.extend(list2)                                  <- adds element of list2 at the end of list1

   - reverse(): we can reverse the elements of a list with reverse():
   ex. list1=["Atti","Tibi","Shivan","Gauron","Feri"]
       list1.reverse()                                      <- reverses the order of the list

   - sort(): we can sort the list in alfabetical order with sort().In strings Big letter comes before small letter. sorting in place, 
   ex. list1=["Atti","Tibi","Shivan","Gauron","Feri"]
       list1.sort(reverse=True)                             <- reverse is putting the elements in alfabetical order  z-a
	   list1.sort()                                          <- natural ascending sort
   
   - sorted(): if we want the result of the sorting in another variable:
   ex. l=sorted(lista)
   
   - +: we can join 2 list with the + operator:
   ex. list1=["Atti","Tibi","Shivan","Gauron","Feri"]
       list2=["1","2","3"]
	   list3=list1+list2
   
   - list(): we can create a list by using the list constructor:
   ex. list1=list("Atti","Tibi","Shivan","Gauron","Feri")
       print(list1)
   
   - we can acces list in list:
   ex. list1=[["Atti",1],["Tibi",2],["Shivan",3],["Gauron",4],["Feri",5]]
       a=list1[1][1] 	   <- "2"
	   
   - for: we can make a list with a for:
   ex. data(1,2,3,4,5)
       selectitem=[mylist[1] for mylist in data]
	   
   - if we want to find a string in a list:
   ex. l=["wer","dffg","erty"]
       if("wer" in l:                 <- true because wer is an element in language
	   if("w" in l:                   <- false because w is not an element in l(it is part of an element in l)

   - max(): we can found the max value element in a list with the max() function:
   ex. print(max(listname))
        print(max(1,2,3))
   
   - min(): we can find the minimum value in a list with the min function:
   ex. print(min(listname))
       print(min(1,2,3))
   
   - choice(): we ca nreturn a random element from a list:
   ex. import random
		list=["asda","dfgD","ert"]
		random.choice(mylist)
   - shuffle(): we can randomly reorganiza a list with shuffle() method.it reorganizes it, does not return a new list:
   ex. import random
		list=["asda","dfgD","ert"]
		random.shuffle(mylist) 
		
   - we can check a particular elements index position with the index() function:
   ex. names=[1,3,5,6,2,34,4]
       a=names.index(5)
   
   - we can join elements of a list into string:
   ex. l = ["sdfs","sdf","GDFG"]
       k="".join(l)   

!!!- count() we can count how many times an element apears in a list:
	ex. names=[1,3,5,6,2,34,4]
	    a=names.count(3)
		
	- index() - we can find the position of an element.If element not in the list then Value Error (need Try - Except)	
	ex. names=[1,3,5,6,2,34,4]
	    a=names.index(3)                      <- 1
		
list comprehension:
----------------------------------------------------------
   - syntax:
       newlist = [expression for item in iterable if condition == True]
	   newlist = [expression for item in iterable]
   - we can generate lists with expression in one line of code
   ex. lll=[2*nr for nr in range(1000)]		   <- generates a list where every element is *2
   ex. lll=[ 2*nr for nr in range(1000) if nr%2==0]      <- generate a list with every element to the power of 2 if the elem. is even 
   ex. lll=[ x if x%2==0 else 1 for x in range (0,11)]
   ex. lll = [x*y for x in [1,2,3] for y in [4,5,6]]     <- equals with nested for loops -> 4,5,6,8,10,12,12,15,18
		
tuple:
----------------------------------------------------------
   - a tuple is an ordered container that is not modifiable and accepts duplicates .we cannot add new elements to it after it is created or change the elements
   - we can define a tupel with :
   ex. t=(1,2,3,4)                            <- tuples are created with (), lists with []
       print(t, type(t))
   
   - we can asign tuples to variables :
   ex. t=("1","2","3")
       a,b,c=t          <- a=1,b=2,c=3
	   
   - we can assign variables to tuple of tuples:
   ex. mytuple=(1,"f"),(2,"ty"),(3,"ert")
       a,b,c=mytuple
       number,name=a        <- number=1, name="f"
	   
   - tuple(): we can define a tuple with the tuple constructor:
   ex. thistuple=tuple(("apple","banana"))
   
   - []: we can acces a tuple with []:
   ex. thistuple=tuple(("apple","banana"))
       print(thistuple[1])
   
   - in: we can check if a value tuple is in a tuple:
   ex. thistuple = ("apple", "banana", "cherry")
       if "apple" in thistuple:
   
   - we can make a list from a tuple:
   ex. n = (1,2,3)
       a = list(n)
	   
   - sum() we can have the sum of the collection with the sum() function:
   ex. a=sum(iterable, start)
   
   - we cant change a tuple but can create a list that can change the values, and then convert to a tupple:
   ex. x = ("apple", "banana", "cherry")
       y = list(x)
       y[1] = "kiwi"
       x = tuple(y)
   
   - append(): we cant add new elements to a  tuple by changing i t to a list , adding items then converting to tupple
   ex. thistuple = ("apple", "banana", "cherry")
       y = list(thistuple)
       y.append("orange")
       thistuple = tuple(y)
   
   - remove(): we cant move items from a tuple but can convert to a list, remove and then convert back:
   ex. thistuple = ("apple", "banana", "cherry")
       y = list(thistuple)
       y.remove("apple")
       thistuple = tuple(y)
   
   - del: we can delete the tuple completely:
   ex. thistuple = ("apple", "banana", "cherry")
       del thistuple
	   
   - we can acces a tuple with negative indexing:
   ex. thistuple = ("apple", "banana", "cherry")
       print(thistuple[-1])
	   
   - we can acces a ranged index:
   ex. thistuple = ("apple", "banana", "cherry", "orange", "kiwi", "melon", "mango")
       print(thistuple[2:5])
    
   - we can create a tupple with only one item:
   ex. thistuple = ("apple",)          - we need , after the item
       print(type(thistuple))
	   
   - type(): we can find out the tuples type:
   ex. thistuple = ("apple",)
       print(type(thistuple)
	   
   - we can cycle throu the tuple :
	   for x in t:
	     print (x)
   
   - we can create list of tuples:
   ex. lista=[("gdfg",2),("rtyR",5),("xcvx",4)]
       print(sorted(lista))                        <- it will sort by default after the first element in the pair   
   
   - we can have tuples in lists:
   ex. list[(1,1),(1,2),(3,4)]                                          
       list.append((1,1))
   
   - tuple: we can use the constructor to construct  a tuple:
   thistuple=tuple(("apple", "banana"))
   
   - we can acces tuple in list:
   ex. list1=[("Atti",1),("Tibi",2),("Shivan",3),("Gauron",4),("Feri",5)]
       a=list1[1][1]                               <- "2"
   
   - len(): we can find the tuple's length with len()
   ex. thistuple = ("apple", "banana", "cherry")
		print(len(thistuple))
   
   - we can unpack a tuple:
   ex. fruits = ("apple", "banana", "cherry")
       (green, yellow, red) = fruits

   - If the number of variables is less than the number of values, you can add an * to the variable name and the values will be assigned to the variable as a list:
   ex. fruits = ("apple", "banana", "cherry", "strawberry", "raspberry")
       (green, yellow, *red) = fruits  
   
   - in: we can iterate through a tuple:
   ex. thistuple = ("apple", "banana", "cherry")
       for x in thistuple:
			print(x)
		
   - we can loop through the index of the tuple:
   ex. thistuple = ("apple", "banana", "cherry")
       for i in range(len(thistuple)):
		   print(thistuple[i])
		   
   - we can join 2 tuples:
   ex. tuple1 = ("a", "b" , "c")
       tuple2 = (1, 2, 3)
       tuple3 = tuple1 + tuple2
   
   - if we want to multiply the content of a tuple a given number of times we can use the *:
   ex: fruits = ("apple", "banana", "cherry")
	   mytuple = fruits * 2 

   - count(): we can find how many times an item occurs in a tupple:
   ex: thistuple = (1, 3, 7, 8, 7, 5, 4, 6, 8, 5)
       x = thistuple.count(5)  

   - index(): we can find the first occurence of a value in the tuple:
   ex: x = thistuple.index(8)
 
   - max() - we can return the element with max value from the tuple:
   ex. tuple2 = (1, 2, 3)
       a = max(tuple2)
   - min() - we can return the element with min value from the tuple:
   ex. tuple2 = (1, 2, 3)
       a = min(tuple2)
	   
named tuple:
----------------------------------------------------------
    ex. import collections
        collections.namedtuple()
        ex. t=5,2,7         <- defining
	- we can acces:
	ex. t[0]
	
	ex. Carte.collections.namedtuple("Carte", "titlu autor")         <- it has 2 field one is titlu, one is autor
	    carte2=Carte('Poezii','Lucian Blaga')
		print(carte2.autor)
	Personana.collections.namedtuple("Persoana","nume prenume varsta")
	p1=Persoana("Negru","Maria",33)
	
	
dictionary in python
----------------------------------------------------------
   - key value type of containers of dict type class
   - dictionaries are collection that is ordered, changeable and do not allow duplicates
   - we can define a dictionary as follows:
   ex. thisdict = {"brand":"Ford","model":"Mustang","year":1984}
   ex. d=dict()
   ex. d={} 
   ex, thisdict = {id:"Ford",name:"Mustang",year:1984}            <- id, name,year variables
   ex. thisdict = dict([("id",1984),("name","washer")]}
   ex. thisdict=dict(zip(("id","name","size"),("nr","where","year")  )      <- The zip() function takes iterables , aggregates them in a tuple, and returns it.
                                                                           If 1 iterable, returns list with distinct elements, if different nr of elements then returns a list with nr of tuples that the shortest 
																		   list number of element has
	   print (thedict}                                     <- [("Id","nr"),("name","where"),("size","year")];
   
   - we can have dictionary in dictionary:
   ex. d=dict("France":{"cities visited":["Paris","Lle","Stutgart"])       <- dictionary within a dictionary 
   
   - we can add a new item in the dictionary by using a new key index and assigning a new value to it:
   ex. car = {"brand": "Ford","model": "Mustang","year": 1964}
       x = car.keys()
	   car["color"] = "white"            <- add new element to the dictionary
	
   - we can change an item in the dictionary :
   ex. car = {"brand": "Ford","model": "Mustang","year": 1964}
	   car["brand"] = "Bmw"            <- change element element in the dictionary
	   
   - len(): we can find the length of the dictionary with the len() function:
   ex. print(len(thisdict))    
   
   - we can acces the value of a dictionary with:
   ex. thisdict = {"brand":"Ford","model":"Mustang","year":1984}
       x=thisdict["model"]           <- if key notin dictionary then error
	   x=thisdict.get("model")       <- with get if key is not in dictionary it will not give exception, it returns None
   
   - keys(): we can have a list of all the keys in the dictionary:
   ex. x=thisdict.keys()           <- it is not a new list, it is a view

   - values(): we can have a list of all the values in the dictionary with the value() function:
   ex. x = thisdict.values()        <- it is not a new list, it is a view
   
   - items(): we can have a list of all the key:value pairs as tuples:
   ex. x = thisdict.items()
   
   - in: if we want to find out if a key exist in the dictionary we can with the in keyword:
   ex. car = {"brand": "Ford","model": "Mustang","year": 1964}
       if "model" in car           <- true if "model" is a key
	   
   - update(): we can update the dictionary with the update() method:
   ex. car = {"brand": "Ford","model": "Mustang","year": 1964}
       bike = {"bmx":"medium", "pegas":"small"}
       car.update({"year":1970})
	   car.update(bike)
   - we can join 2 dictionaryes with update():
   ex. fruit={1:"a",2:"b",3:"c"}
       veg={"a":"lemon","b":"aple","c":"orange"}
       veg.update(fruit)
   
   - pop(): we can remove items from the dictionary with pop():
   ex. car = {"brand": "Ford","model": "Mustang","year": 1964}
       car.pop("model")
   
   - popitem(): we can remove the last item of the dictionary:
   ex. car = {"brand": "Ford","model": "Mustang","year": 1964}
       car.popitem()
   
   - del(): we can remove an item with a key name:
   ex. del car["model"]
   
   - we can delete the entire ditionary:
   ex. del car
   
   - clear(): we can clear the dictionary with the clear method, leaving the dictionary empty:
   ex. car.clear()
   
   - for: we can loop with the for through the dictionary:
   ex. for x in car
		print (x)                      <- will print all keys in the dictionary
	
   - we can iterate through all the values in the dictionary:
   ex. for x in car
		print(car[x])
   
   - values(): we can iterate through the values in the dictionary:
   ex. for x in car.values():
		print (x)
		
   - key(): we can use the key() function to iterate through the keys of a dictionary:
   ex. for x in car.keys():
         print(x)
   
   - items(): we can loop through the key:values pair with the items() function
   ex. for x,y in car.items():
		print (x,y)
   
   - copy(): we can copy a dictionary:
   ex. mycar=car.copy()
       mycar=dict(car)
   
   - we can create a dictionary that contains an other dictionary:
   ex. myfamily={"child":{"name":"Emil","year":2004},..}   

   - for: we can acces the items and iterate with for:
   ex. for item in d.items():
		print(item[0], item[1])
   ex. for key,value in d.items()
			print(key,value)
			
   - get() return a value for a given key.If the key is not found then returns None
   ex. fruit={1:"a",2:"b",3:"c"}
       print(fruit.get(3)  

   - viewitems() - we can see the dictionari in a list form where the key values are tuples:
   ex. d= {k1",1,"k2",2}
       print(d.viewitems())           <- dict_items[("k1",1),("k2",2)]  

   - viewkeys() - we can have a list with the keys
   ex. d= {k1",1,"k2",2}
       print(d.viekeys())             <- dict_keys(["k1","k2"])

   - viewvalues() - we can have a list with all the values in the dictionary:
   ex. d= {k1",1,"k2",2}
       print(d.vievalues())             <- dict_values([1,2])

dictionary comprehension:
-----------------------------------------------------------------
   - syntax:
   ex. newdict = {newkey:newvalue for (key,value) in dict.items()}            <- dict.items() are the pair of key values from the dictionaries 
       newdict = {newkey:newvalue for (key,value) in dict.items() if condition True} 
   ex. names = ['Alex","Feri","Tibi"]
       student_score = {student:random:randint(1,100) for student in names}
   
   ex. student_score = {"Alex":24,"Tibi":34,"Feri":12}
       passed_student = {student:scores for (student,score) in student_score.items() if score>=15)   

set in python:
-----------------------------------------------------------------
   - set is unordered, unchangable(just remove and add items) and unindexed, dont allow duplicates, and can be of any type (even mixed)
   - duplicate elements will be ignored
   
   - we can create a set:
   ex. s=set()
       ss={2,2,1,4,5,'casa',True}                     <- set will automatically order the set
   
   - we can create a set from range:
   ex. numbers=set(range(0,10,2))
   
   - we can create a set from list:
   ex. numbers=(4,5,6,7)
       setnumbers=set(numbers) 

   - we can acces items in the set:
   ex. thisset = {"apple", "banana", "cherry"}
	   for i in thisset
          print(i)
   
   - we can search for an item in the set:
   ex. a={"a","b","c","d"}
       if "a" in a
	   
   - sum() we can have the sum of the collection with the su() function:
   ex. a=sum(iterable, start)
   
   - clear(): we can clear a set with clear() method:
   ex. thisset = {"apple", "banana", "cherry"}
	   thisset.clear() 
	   
   - del(): we can delete the set completely:
   ex. thisset = {"apple", "banana", "cherry"}
       del thisset
	   
   - add(): we can add a new element to the set with the add()
   ex. thisset = {"apple", "banana", "cherry"}
	   thisset.add("orange")

   - remove(): we can remove an item, and if it is not in the set it will give an error:
	ex. thisset = {"apple", "banana", "cherry"}
        thisset.remove("banana")     <- if the item is not then error
		

   - discard() : we can remove an item without errors:
   ex. thisset = {"apple", "banana", "cherry"}
       thisset.discard("banana")    <- if element is not then will not be error
	   
   - update(): we can add a set to an other set with update()
   ex. thisset = {"apple", "banana", "cherry"}
       tropical = {"pineapple", "mango", "papaya"}
       thisset.update(tropical)

   - pop(): we can remove the last item with pop()
   ex. thisset = {"apple", "banana", "cherry"}
       x = thisset.pop()                <- because unordered we dont know which is the last element
   
   - sorted(): we can sort the set and put elements in a new container (set cannot be oredered!)
   ex. list=sorted(set)
   
   - type(): we can find the type of a sort with type()
   ex. print(type(set))
   
   - len(): we can find the length of a set:
   ex. thisset = {"apple", "banana", "cherry"}
	   print(len(thisset))
	   
   - split(): we can make a unique collection out of a text:
   ex. import sys
       nume_scrypt=sys.argv[0]           <- name and path of py script
   	   s=set()
	   with open(nume_script,'rt') as file:
		for linie in file:
			cuvinte=linie.split()
			s.union(set(cuvinte))
   
   - we can iterate over a set:
   ex. thisset = {"apple", "banana", "cherry"}
       for x in thisset:
   
   - union(): we can add a set to another set:
   ex. set1 = {"a", "b" , "c"}
       set2 = {1, 2, 3}
       set3 = set1.union(set2) 
   ex. myset.union(set1,set2,..) 
   
   - intersection_update(): we can keep both the duplicates from 2 sets:
   ex. x = {"apple", "banana", "cherry"}
       y = {"google", "microsoft", "apple"}
       x.intersection_update(y)
   
   - differnece_update() remove the items that exists in both sets
   ex. x = {"apple", "banana", "cherry"}
       y = {"google", "microsoft", "apple"}
       x.differnece_update(y)
	   
   - intersection(): returns a set that contains the item that exists in both set x and y:
   ex. x = {"apple", "banana", "cherry"}
       y = {"google", "microsoft", "apple"}
       x.intersection(y)
   
   - symmetric_difference_update(): we can keep all but not the duplicates in 2 sets:
   ex. x = {"apple", "banana", "cherry"}
       y = {"google", "microsoft", "apple"}
       x.symmetric_difference_update(y)
   
   - symmetric_difference(): returns a set that contains all the items from both sets, except items that are presentin both sets:
   ex. x = {"apple", "banana", "cherry"}
       y = {"google", "microsoft", "apple"}
       x.symmetric_difference_update(y)
	   
   - copy(): we can make a copy of a set in another set:
   ex: fruits = {"apple", "banana", "cherry"}
       x = fruits.copy()  

   - difference(): we can find the difference between 2 sets:
   ex. x = {"apple", "banana", "cherry"}
       y = {"google", "microsoft", "apple"}
       z = x.difference(y) 
   
   - isdisjoint(): returns true if no item in set is present in set y:
   ex. x = {"apple", "banana", "cherry"}
       y = {"google", "microsoft", "apple"}
       z = x.isdisjoint(y)	
   
   - issubset(): returns true if all the items in set x is present in set y:
   ex. x = {"apple", "banana", "cherry"}
       y = {"google", "microsoft", "apple"}
       z = x.issubset(y)  
	   
   - issuperset(): returns true if all the items in set y is present in set x:
   ex. x = {"apple", "banana", "cherry"}
       y = {"google", "microsoft", "apple"}
       z = x.issuperset(y)  

    - frozenset(setname)  <- we can make a set inmutable with frozenset:
    ex. frzset = frozenset(setname)	

generators:
-----------------------------------------------------------------
   
   - the "yeild" keyword replaces the "return" keyword in a function , and returns a value in a collection of values, but retains the state of the function,
     so that the function returns the next value from the iterable the next time is called, unlike return that returns all the values at once
	Ex. def simple_gen():
			for x in range (3):
				yield x**x             <-  
				
		for y in simple_gen():           <- simple_gen() will return value one by one, will not make a list of elements consuming memory , but it will return one element
			z+= y
	 
generator comprehension:
-----------------------------------------------------------------
	- we can generate elements one by one with generator comprehensions:
	Ex. g = (x for x in range(0,5) if x>3)
   
	   
sorting in python:
-----------------------------------------------------------------
   - we can sort inplace:
   ex. l=[1,2,3,4,5,3,4]           
       l.sort()                  :not create a new list 
   
   - sorted(): we can sort a list and the result is a new list saved in a new variable
   ex. l=[1,2,3,4,5,3,4]
       ll=sorted(l) 
   
   - sorted(): we can sort a list and the result is a new list with custom sorting functions
   ex. l=[1,2,3,4,5,3,4]
       ll=sorted(l, key=fct)                  <- key=fct is a function name of a fucntion  that is used to sort the elements 
       def fct(nr):
			return abs(nr)                    <- returns absolute number for every element in the list
   
   - sorted(): we can sort after a key function:
   ex. l=["Masa","Apa","Birou"]
		ll=sorted(l,key=f),                    
		print(ll)
		def f(string: str):                     <- anotation   type it tells that str is of type string   
			return string.lower()               <- changes all to lowercase and then sort naturally
   
   ex. l=["Masa","Apa","Birou"]
		ll=sorted(l,key=f),                    
		print(ll)
		def f(str):                     <- anotation   type it tells that str is of type string   
			return len(str)             <- it will return the length and then the sorting will happen naturally  after the length
   
   - we can use a lambda function.functions are there to provide a different value after the sorting will sort naturally
   ex. l=["Masa","Apa","Birou"]
		ll=sorted(l,key=lambda s: s.lower()),                    
		print(ll)

    
exceptions:
-----------------------------------------------------------------
   - exceptions is a mechanism to treat errors in programs 
   - it returns values, it has a global variable errno
   Ex:  try:           <- block of code that can give exception
		except:        <- what to do in case of exceptions
		else:          <- if code did not give exception, what to execute
		finally:        <- what code to execute regardless if it was an error or not
   - try block lets test a block for errors
   - except let us handle the error
   - else lets execute code if there is no error
   - finally if specified, will be executed regardless if a block raises an error or not
   - if an exception apears and it is not treated, program will crash
   ex. try:
		 print(x)
	   except:
		 print("An exception occurred")
		 
   ex. while True:
        try:
           x = int(input("Please enter a number: "))
           break
      except ValueError:
          print("Oops!  That was no valid number.  Try again...") 
   ex. linie=input("esti minor?")
       try: 
          varsta=int(linie)                                   <- trys to convert string to int
	   except ValueError as err:
	      print('am prins exceptia',err)                      <- if exception se executa lina asta
   
   ex. try:
         varsta=int(linie)
		 if varsta<18
		    print("esti mnor")
		 else:
		     print("esti major")
	   except ValueError as err:
	     print("am prins exceptia!", err)
		print("!!!!!")
	   except TypeError as err:
	     print("am prins exceptia")
   
   - we can have an else after the try - except with code that is not intended to give exception <- recomended way
   ex. try:
			f=open(arg,'r')
		except OSError:
            print(arg, "has", len(f.readlines()), "lines")
			f.close()
		else:
		   print("yuhuuu!")
   
   - we can have multiple many exceptions to handle an error:
   ex. try:
         print(X)
	   except ValueError:                                   <- ValueError standard python exception from the library
	     print("variable x is not defined!")
	   except TypeError:                                    <- TypeError standard python exception 
	      print("something else went wrong!")
	   else:
	     print("yuhuuu!")
	
	- we can have finally to be executed regardless if there was exception or no:
	ex. try:
         print(X)
	   except NameEror:
	     print("variable x is not defined!")
	   finally: 
		f.close()                  <- closes file 
   
   - we can raise an exception if certain condition occurs:
   ex. x=-1
       if x<0:
	   raise Exception("Sorry, no numbers below zero")
	   
  ex. if x<0:
		raise KeyError("This is a thrown error!")             
   
   - we can define the type of error to raise and the text to print to the user:
   ex. x="hello"
       if not type(x) is int:
	      raise TypeError("Only integers are allowed!")
		  print("Not executed")
   ex. def work():
          raise ValueError('am patit-o!')
	   
	   def f():
		try:
			work()
		except ValueError as err:
			print ("exception caught", err)
	- we have base exception, and any custm exception needs to inherit from BaseException!! 
    
	- error mesages can be catched with the as keyword:
	ex. try:
	        dictionary = {"key":"value"}
			print(dictionary["asda"])
		except KeyError as errormsg:                <- errormsg contains the error message
			print (f"{errormsg}")
			
	- if we can have multiple errors in a try block, it i wise to treat it with a specfic Except error type:
    ex. try:
           file = open("file.txt")
           dictionary={"key":"value"}
           print(dictionary["asd"])
        except FileNotFoundError:	
           print("file not found error catched!
        except KeyError as error_mesage:         
		   print(f"{error_mesage}")
	
	- assert - we can stop the code with an assert type of exception:
	ex. a = 6
	    assert a == 5                    <- AssertionError  assert a==5
		

eval and exec:
-------------------------------------------------------------------
   - eval and exec are functions that translate strings into python code
   - !!it allows users to run code in your code
   - eval - it evaluates code - can run functions and simple operations
   - exec - it can execute code , can create functions and variables
   ex. print(eval ("10+3"))                            <- prints 13
       print(eval(""test".upper()"))                   <- TEST
	   exec("a=10")                                    <- a=10
	   
   
working with files
-------------------------------------------------------------------
   - file acces mode: r - read, a - append, w - write, x - create, t - text mode, b - binary mode
   - open(): we can open a file with the open function: open mode: w - write, r- read, t- text     - more on help
   ex. fileout=open("filename.txt","wt", encoding='asci')                       <- if not pathname then file in same folder, encoding flag optional 
   
   - python processes unicode 16/32, a text file is utf-8 - python traduces to utf-8. if not specified in open then then the standard 
   - if we used the fileout=open syntax, we need mandatory to close the file after we worked with it:
   ex. fileout.close()
   
   - write(): we can write a line to a opened file:
   ex. fileout.write("prima linie!")
   
!!!- the recomended way of opening  and writing a file in python is:   - it closes the file automaticaly!!
   ex. with open ("a.txt", "wt") as fileout:
      fileout.write("prima linie!")
      fileout.write("a doua linie!")
	ex. textlist = ["Dear Name:","I anounce you that i am maried.","see you on my wedding."]
        with open("stas.txt","wt") as inputfile:                                               <- writes the whole text line by line to a file with newline at the end
        for i in textlist:
            inputfile.write(i+"\n")
	
!!!- the recomended way of reading a file in python is:
   ex. with open("a.txt",'rt') as filein:         - r read  t text
           for linie in filein:                            <- the line from the file is read with the new line at the end
              linie=linie.strip()                          <- removes \n from the end of line    
			  lista.append(linie)	

!!!- the recomended  read a file in the memory like a list of multiple lines(file will be closed after use automatically):
   ex. with open ("a.txt") as filein:
         continut=filein.readlines()       <- reads the file line by line and ads it to the  list
         print(continut)		 

!!! the recomended way of writing in a file multiple lines which closes the file automaticaly after usage:
   ex. with open("a.txt",'rt') as filein: 
       filein.writelines(["\nSee you soon!", "\nOver and out."])
	   filein.writelines(listname)   
   
   - we can read a file in the memory like a single line:
   ex. with open ("a.txt") as filein:
         continut=filein.read()       <- reads the file like a long  string
         print(continut)
   
   - we can read from a file line by line and encode in utf8:
   ex. with open('quotes.txt', encoding='utf8') as f:
           for line in f:
				print(line.strip())                        <- strip() removes \n from end of line
		 
   - we can read an undefined number of arguments from the comand line:
   ex. for filename in sys.argv[1:]:   <- all the arguments after the filename
          with open(filename) as fin:
	        
   - we can append to the end of a file:
   ex. varosok=["Temesvar","Arad", "Deva"]
       with open("C:\\Temp\\temp.txt",'a') as varosfile:
       for varos in varosok:
          print(varos,file=varosfile)
		  
	- os.getcwd():we can get the current working directory:
	Ex. import os
		a = os.getcwd()          <- get current working directory   -> "C;\\Users\\Documents"
   - os.path.isdir(): we can check if a string is a foldername with os.path.isdir()
   ex. import os
      if not os.path.isdir(folderstringname):
          print (f'{folderstringname} is not a foldername!')	   
   
   - isfile(): we can find if the content of a directory list is a file with the isfile():
   ex. for intrare in os.listdir(folder):
			if os.path.isfile(f'{foldername}/{intrare}')                 <- or if os.path.isfile(numelefisieruluicucalea)
				print(intrare)
  ex.file=r'C:\\dir\\file.py'   <- windows style folder notation
     file=r'C:\dir\file.py'                  <- raw it tels the \ sign to njot use as a command characte (\n,\f,\t, etc)
	 file='C:/dir/file.py'
	 path_name=rf'{folder}\{intrare}'
	 
	- shutil.move() - we can move files from one directory to other:
	ex. import shutil
		shutil.move("prqctice.txt","C:\\Users\\Documents")  <- moves practice from the working directory to the C:\\Users\\Documents folder
	
	- os.unlink() - we can delete a file at the specified path, filename included in the string. deleted files will not get in the recycle bin
	ex. import os
		path = "/home / ihritik / Documents / file1.txt"
		os.unlink(path)
	
	- os.rmdir() - we can remove a folder. deleted files will not get in the recycle bin
    ex. import os
		os.rmdir("C:\\Users\\Documents")
		
	- shutil.rmtree(path) - we can remove a directory tree. deleted files will not get in the recycle bin:
	ex. import shutil
		shutil.rmtree("C:\\Users\\Documents")
		
	- send2trash() - we can delete a file by sending it to the trash:
	Ex. pip install send2trash 
		import send2trash
		send2trash.send2trash("practice.txt)                <- delete the practice.txt file from the current working directory
	
	- os.walk ()- we can get the content of the path in a tupple in the folowing order: Folder, subfolder, files:
	Ex. import os
		file_path = "C:\\Users\\Documents"
	    for folder,subfolder,files in os.walk(file_path):
			print(f"we are looking to the {folder} foler")          <- folder is the current working folder
		for i in subfolder:
			print (f"the subfolders are {i}")
		for j in files:
			print (f"the files are {j}")
		
		
   - exists(): we can find out if a file exist or not with exists().if there is no such file, False, else True:
   ex. from os.path import exists
       fileexists=exists(path to file)
   ex. import os.path
       os.path.exists(path to file)
          
   - we can get a files size in bytes:
   ex. import os 
      os.path.getsize(pathwithfilename)
   ex. for intrare in os.listdir(folder):
          path_name =f'{folder}/{intrare}'
		  if(os.path.isfile(path_name):
			size=os.path.getsize(pathname)
			print(f'{contor:3},{intrare:5},{size<6}')
   
   - we can make a list of files with size:
   ex. fisiere[]
       for i in os.listdir(path)
	      path_name -rf'{folder}\{intrare}'
		  if os.path.isfile(path_name)
		  size=os.path.getsize(path_name)
		  fisiere.append((size,intrare))                  <- appends a tuple to the list
		print(fisiere)
		sortate=sorted(fisiere)
		for cnt,t in enumerate(sortate,1):                     enumerate(sortate,1)   <- starts with element 1
		   print(f'{cnt:3},{t[1]:22}, {t[0]:4}')

   - we can delete a file: 
   ex. import os
       os.remove("myfile.txt")
   
   - we can delete a folder:
   ex. import os
       os.rmdir("sample data") 
   
   - we can have relative and absolute paths:
      - relative path:      <- it is relative to the position we are currently
	  	  ./Project/readme.txt    <-  we are going down in the project folder and then we find the file readme.txt
	  - absolute path:      <- it is the absolute pathname
		 d:/This/Project/readme.txt     <- we got absolute path
		 /This/Project/readme.txt        <- in the same drive as the script is in
   - we can go up in directory and then down:
	  - ../../Projet/readme.txt         <- we going up 2 levels and then going down the project folder to the readme.txt
	  
   - in python the current path is the path where we launched the script
   - we can write binary data to a file:
   ex. with open("binary",'bw') as binfile:
       for i in range(17):
         binfile.write(bytes([i])                              /must be converted to binary otherwise error
   - we can read binary data from a file:
   ex. with open("binary",'br')as binfile:
       or b in binfile:
         print(b)
	   
pickle and serialization
------------------------------------------------------------------
   - through serialization we convert from program obiect format to json,xml,etc
   - through deserialization we convert from json, xml, to program obiect format
   
   - we can write objects:
   ex. import pickle
       with open ("db.bin", 'wb') as input                <- open for write as a binary file
	   l=[1,3,'casa']
	   pickle.dump(l,input,pickle.HIGHEST_PROTOCOL)           <- HIGHEST_PROTOCOL compression algoritm to max - first dump in the file
	   pickle.dump('pom',input,pickle.HIGHEST_PROTOCOL)       <- second dump, pom is a string that is dumped in the file after the list l
   
   - we can read objects:
   ex. with open('db.bin','rb') as f:                    <- open for read as a binary file
       a=pickle.load(f)                                  <- every load loads the every dump with write
	   print(a)
	   b=pickle.load(f)                                  <- loads the second dump from the write
	   print(b)
   ex. with open ("file.pickle","rb") as picklefile:
       text2=pickle.load(picklefile)
       album,artist,name, tracklist=text2
       for track in tracklist:
            a=tracklist[0]
            b=tracklist[1]
	
	- we can use json for serialization write - json does save everything in lists so other containers types will be lost 
   ex. import json	
       with open ("db.json", 'wt') as inputfile                <- open for write as a text file forjson
	   mylist=[1,3,'casa']
	   json.dump(mylist,inputfile, indent=4)           <- problem withjosn that is only one dump and we cant dump just 1 object unlike pikle
															indent means it will output it to a more readable format in the file(for eyes)
   - we can use json for deserialization read:
   ex. import json
       with open ("db.json", 'rt') as output
	   l=json.load(output)
	   
   - we can use json to update in a file an already saved json database:
   ex. with open ("data.json", "r") as data_file:
		data=json.load(data_file)
		data.update(new_data)
	   with open ("data.json", "w") as data_file:
	   json.dump(data, data_file,indent = 4)


functions
---------------------------------------------------------------
   - main() is a variable that points to the function main() (just for main function)
   - a function needs to be defined before use
   - argument is the name of the placeholders in the function definition and parameter is the name of data that receives the values when the function is called 
     condition is that it has to be defined before it is called
   - functions called with different numbers of arguments give error
   - a function that returns nothing returns None
   - a function can return something or nothing in the same time (if -> return True -> else -> Pass)
   - a functions arguments are references to  the arguments so it can be modifyed and they modifys the passed variables
   - if we dont know how many arguments will be, we add a * in front of argument name
   - in python there is no method overloading
!!!- we can specify the type of the argument a function receives and the return type :
   ex. def func(l: list, index: int) -> int:          -> return type int, arguments are list and int types
   
   - we can assign functions to variables and call them through the variables:
   Ex. def func():
			return True
	   a = func                <- a function is an object that can be passed to an other object
	   a()                     <- calls the func method
	   
   - functions can return values: they do with the return variable keyword
   ex. def func(n):
		return n*n*n
   
   - functions can return more values:
   ex. def test2():
		  return 'abc', 100, [0, 1, 2]
	   a, b, c = test2()   
   ex. def funcname (*arg):
         print (arg[2])
   
   - we can call a function with variable number of arguments: the passed argument will be wraped in a tupple, so we can iterate through it:
   ex. def func(*f):                              <- f will be a tupple
		 for i in f
			print(i)
	   func("1","2")

   - we can pass a list or tuple to a function that expects more elements:
   ex. l=[1,2,3]
       def f(a,b,c):
	      print(a,b,c)
	   f(*l)                          <- *l tells python that he needs to unwrap the list to the variables the function expects(l[0]=a,l[1]=b,l[3]=c
	   
   - we can call functions with variable keyword arguments.the argument passes like a dictionary in the function, but parameter not a dictionary {'name of variable':value} pairs:        
   ex. def funcname(**kid):
            print(kid)                 <- kid becomes a dictionary
       funcname(name="Tobias",lname="Frank")
	   funcname()
	   funcname(name="Feri")  
	   
   - we can acces the arguments passed like dictionary in the function( unknown number of arguments):
   ex. def funcname(**kwargs):
       for key,value in kwargs.item():
		 print (key,value)
		 print(kwarg[key])
		 
   - ex. def funcname(n, **kwarg):
         funcname(5, car = green, wheels = 4)
		 
   - we can pass in a variable number of values and key value types:
   ex. def myfunc(*args, **kwargs):
		 print (args)
		 print(kwargs)
	   myfunc(1,2,3,fruit="orange",food="eggs")           <- 1,2,3 args tuple; fruit,food kwargs argument
		 
   - we can pass a dictionary as a function parameter element by element
   ex. info{'start':0,'stop':1,'step':2}
       def f(start,stop,step):
			print(start,stop,step)
	   f(**info)
   
   - we can pass a tuple and dictionary as function parameters:
   ex. def f(a, *f, **d):                  <- a is mandatory if we have something without a *
		print (a,f,d)                  
       f(1,2,x=88)                          <- 2 will be treated as a tuple, x as a dictionary
   
   - we can use default parameter value - default parameter value is written in the definition of the function
   ex. def myfunc(country="Norway"):                   <- default parameters are defined in function definition
         print(f"I am from {country}")
   
   - we can define a function that does nothing  with a pass
   ex. def myfunc(): pass
   
   - we can pass arguments through name <- keyword arguments are specified when we call the function:
   ex. def numefunctie(a,b,c)
           print(a,b,c)
        numefunctie(c=4,a=3,b=2)          <- c will be in position like c in numefunctie
        numefunctie(2, c=1,b=3)            <- first parameter passing through positional, 2 and 3 through name
		numefunctie(2,c=1,a=3)             <- error , a defined twice     
   
   - a function can be defined in an if:
   ex. a=1;b=4
       if a<3
         def aduna(a,b)
		      return a+b
		print(aduna("sdfs","sdfs"))
   
   - we can exit a function anytime with a return, if return without parameter, then returns "None"
   ex. def func(t):
		print("t")
		return                                     <- function returns None
   
   - we can define our program with a def main():
   ex. def main():                 <- 
       ,.....
	   return
	   main()                      <- execution   
		
   
   - we can define a function folowing way:
   def aduna(a,b)
      return (a+b)      <- indentation important
   
   - we can return multiple things from a function and we can test it:
   ex. def func (a, b)
		if a>b and b not 0
		  return (a+b)
		else
		  return None
   
   - variables  with same name defined global and local in functions, locals will overshadow global. if we tell that glabal keyword, it will acces global
   ex: x=5
       def func(a,b):
	     global x                <- cannot make global x = 3 ->syntax error
		 x = 3                    <- will modify the global variables value outside of the function
		 return x*(a+b)

   - we can have functions in functions:
   ex. def outer_function(a, b):
		 def inner_function(c, d):
             return c + d
         return inner_function(a, b) 
	   result = outer_function(5, 10)
	   print(result)
	   
!!!- we can exchange the name of the function with an alias and call it:
   ex. def add(d,y):
         return d+y
       mydict={"plus":add}            <- dictionary, add is variablename!!  
       x=mydict["plus"](2,3)               <- mydict["plus"] replaces with the add from the dictionary and becomes the function name!!!!
       print(x)
	   
!!! - we can pass functions to function!!!!:
   ex. def add(a,b,func):
          return func(a,b)
	   def func(a,b):
			return a+b
	   print (add(1,2,func))

   - we can have wrapper function (functions that will be called inside another function):
   ex. def add():
          print ("function")
	   def func(function):
			function()
       func(add)
	   
   - we can return a tuple from a function and unwrap it after:
   ex. def tuplefunc():
		 return ("Today",3)                       <- tuple
		main():
			day, dat = tuplefunc()
			record = tuplefunc()          <- record is a tuple
			
   - we can have default values in the functions:
   ex. def myfunc(a=5,b=6,c=7):
       myfunc(b=7)                           <- the function will take default arguments except b that is given, a and c will be 5 and 7
   ex. def myfunc(a,b=2,c=3)
       myfunc(5)                            <-a=5, rest is default
	   
	- in python overriding method is defining the same name method in the subclass
	- if we want to refer to the super class methodname we can call it with super
	ex. super().metodanem(argument)
	   
lambda functions
------------------------------------------------------------------
   - lambdas are functions defined in the place it is needed
   - lambda functions can take any number of arguments , but can have only one expression
   - syntax :      lambda arguments: expression
   - lambda functions begin with lambda
   - in python a lambda function must be an expression
   ex. lambda s: s.lower()              <- s is an input parameter
   ex. a= lambda a:a+10
       print(a(5)) 

   - we can have multiple arguments in a lambda function:
   ex. x=lambda a,b:a+b
       print(x(1,2))

   - if we have a function that takes an argument and returns a multiplied value of the argument:
    ex. def myfunc(n):
           return lambda a:a*n-1
        mydoubler=myfunc(2)
        print(mydoubler(11))		
	
   - we can have lambda wrapper functions:
   ex. cube=lambda func:func**3
       square=lambda x:x*x
        print("square(cube(2))")
		
   - we can create a lambda function:
   ex. x=lambda a:a+10
       print(x(5))             <- a==5
	   
Functional programming :map(), filter(), reduce() functions:
.............................................................
	- The map function accepts another function and a sequence of iterables as parameters and provides output after applying the function to each iterable in the sequence:
	  functions or lambdafunctions can be used
	  map(function, iterables)
	ex. mylist = [1,2,3,4]
	    t = map(lambda x:x*x, mylist)      <- 1,4,9,16
		
	- The filter() function is used to generate an output list of values that return true when the function is called.functions or lambdafunctions can be used
	  filter(function, iterables)
	ex. mylist = [1,2,3,4,5,6]
        t = filter(lambda x:x%2 == 0, mylist)           <- 2,4,6
		
	- The reduce() function applies a provided function to iterables and returns a single value. functions or lambdafunctions can be used
	  reduce(function, iterables)
	ex. mylist = [1,2,3,4,5,6]
	    t - reduce(lambda x:x==4, mylist)           <- 4
	
	
Objects in python:
-----------------------------------------------------------
   - custom abstract data types
   - inheritance and composition
   - polymorfism
   - generic programming(templates in c)
   - exceptions
   - a class inherits by default the "object" class
   - if a variable is defined outside the __init__ method the it is a class variable(common to all objects), not an instance variable. 
     it is not needed to define it with self, but when acces it then with self
   - every classs has a method __str__() that is the image of the class in string, inherited from "object" superclass but can be overriden
   - when an object is created the __new__() function is called to find space in memory, then the __init__() to initialize the object
   - functions with __x__ are special dunder functions for suporting python class mechanism:
     __nume__(self,....)
   - __new__() returns the self self pointing reference
!!!- every class has a __init__() function that is inherited from the "object" superclass and is always executed when an object is created(constructor)
     if an object does not have the __init__() then it does not initializes any unitialized data
   - if the __new__ is redefined then object creation is tempered with in exotic way
   - __repr__ and __str__ return a string representation of the class where repr returns it in maschine form and can be reconstructed the class from it.__str__ and repr  can override the defaultfunctions:
   ex. myobject.__repr__()      <- the object representation in a string (variable fields separated by comas)
       m2=eval(repr(myobject))     <- will reconstruct m2 from the objects string representation
   
   - we can define a class with:	 
   ex. class Personana:
         def __str__(self):                  <- method, a function defined in the object superclass, overiden with the same name
		    return "aloha!:
   - we can create a class with no code with pass:
   ex. class people:
          pass
   - we can create a class:
   ex. p1=Persoana()
       print(p1)                 <- it calls the .__str__() function of the object that is inherited from "object" - t returns a string representation 
  
  - a class can have class variables and instance variables.Class variables are common to all objects created , instance variables (self.) are particular of a created object
  ex. class Monster(object):
           name = "erfere"                                          <- class variable without self
		   def __init__(self):
		      self.number = 5                                       <- instance variable (with self)
			  
  - we can assign values to variables when we create an object:
   ex. class Person:
		 def __init__(self, name, age):
		    self.name=named
			self.age=age
		def __str__(self)"
			return ("T%his is the class")         <- when print(p1) it will return and print "This is the class"
		 def speak(self)
		    print("{self.name} aloha")
		 
	  p1=Person("John",36)
	  p1.speak()
	  p1.name="Tibi"
	  p1.age=15
      print(p1.__dict__)    <- __dict__ is a dictionary and prints all the elements of the object like a dictionary
	  
!!!- self parameter is a reference to the current instance of the class and is used to acces variables and functions that belong to the class(this in java and c++)
     it does not need to be called self, but needs to be the first parameter of any method of a class
   ex. class Person:
           def __init__(mysillyobject, name, age):
           mysillyobject.name = name
           mysillyobject.age = age
   		   
   - we can acces objects with the object name .variable or function name:
   ex. p1=Person("John",36)
	   p1.speak()            <- Persoana.speak(p1)              <- from this comes the self - p1
	   p1.name="Tibi"         
	   p1.age=15
	- we can have class definition with no content with the pass - we need it because if not then identetion error on next line
   ex. class Person:
        pass   
    - we can redefine the __str_() function to return custom string
	ex. class Person:
		 def __str__(self, name, age):
		    return "f{name} {age}"
constructor:
-----------------------------------------------------------
   - in python the constructor is the __init__() method:
   - we can have parameterized constructors:
   ex. class Person:
		 def __init__(self, name, age):
		    self.name=name               <- declaration and definition , class variables are called atributes
			self.age=age                 <- declaration and definition, class variables are called atributes
		 def speak(self)
		    print("aloha") 
       p1= Person("John",36) 
   def __init__ (self, radius)
    circle=Circle(2)

   - we can have unparameterized constructors:
   ex: class Person:
		 def __init__(self):
		    self.name="Tibi"              <- declaration and definition , class variables are called atributes
			self.age=24        

    - we can have default constructor
	ex. class Student:
	      roll_num=15
		  def display (self)
		     print(self.roll_num)
   
   - we can have multiple constructors in a class:
   ex. class Student:
         def __init__(self):
		       print ("first constructor")
		 def __init__(self):
		       print("the second onstructor")
			   
	- if there are multiple constructors python will always call the last constructor
			 
delete object properties:
-----------------------------------------------------------
   - we can delete object properties:
   ex. class Person:
		 def __init__(self, name, age):   <- metode instanta, overwrite __init__() inherited method from "object"
		    self.name=named              <- declaration and definition 
			self.age=age                 <- declaration and definition
		 def speak(self)
		    print("aloha") 
      p1= Person("John",36)
      del p1.age	                     <- we deleted the properties of the p1 object

object deletion:
-----------------------------------------------------------
   - we can delete an object with del()
   ex. p1= Person("John",36)
       del p1  
	   
Inheritance:
-----------------------------------------------------------
   - in python there are 4 types of inheritance:
      - single inheritance
	  - multilevel inheritance
	  - hierarhical inheritance
	  - multiple inheritance
   - single level inheritance enables a derived class to inherit characteristics from a single class:
   ex. class employee():     <- parent class
          def __init__(self, name,age):
               self.name=named
               self.age=age
       class childemployee(employee):
          def __init__(self, name, age, id):
                employee.__init__(self,named, age)                                 or->super().__init__(named, age)
                self.id=id	
    employ=employee("Tibi", 22)
	
   - multi level inheritance enables a derived class to inherit properties from an imediate parent class that inherits from a parent class
   ex. class employee():
         def def __init__(self, name,age):
               self.name=named
               self.age=age
	   class childemployee(employee):
          def __init__(self, name, age, id):
                employee.__init__(self,named, age)                         or->super().__init__(named, age)
                self.id=id 
	   class childemployee2(childemployee)               <- 
	         def __init__(self, name, age, id, salary):
                childemployee.__init__(self,named, age,id)                 or->super().__init__(named, age,id)
				self.salary=salary
   
   - hierarchical inheritance enable more then one derived class to inherit properties from a parent class:
   ex. class employee():
         def __init__(self, name,age):
               self.name=named
               self.age=age
	   class childemployee(employee):
          def __init__(self, name, age, id):
                employee.__init__(self,name, age)                    same as-> super().__init__(named, age)
                self.id=id 
       	class childemployee2(employee):
          def __init__(self, name, age, id):
                employe.__init__(self,named, age)                   or-> super().__init__(named, age)
                self.id=id 
	 childempl1=childemployee("Tibi",22,324)
     childempl2=childemployee2("Feri",21,321)
   
   - multiple level inheritance enables one derived class to inherit properties from more then one base class:
   ex. class employee():
          def def __init__(self, name,age):
               self.name=named
               self.age=age
		class employee2():
          def def __init__(self, name,age):
               self.name=named
               self.age=age
               self.id=id			   
			   
	   class childemployee(employee, employee2):
          def __init__(self, name, age, id):
                self. name=named
                self.age=age
                self.id=id 
				
   - we can inherit an object from another with the (objectname) method
    ex. class Personana(object):             -<- object is the class that is inherited
	- if we write class Person: it means it is not inheriting anyone
   - a class inherits by default the "object" class:
   ex. class Person:
		 def __init__(self, name, age):   <- metode instanta, overwrite __init__() inherited method from "object"
		    self.name=named              <- declaration and definition 
			self.age=age                 <- declaration and definition
		 def speak(self)
		    print("aloha")
			
	  class Student(Persona):
	     pas
   - when a class inherits an other it gets the other classes properties and methods
   
   - we can initialize the parent class when we inherit with the super keyword:
   ex. class Animal:
          def __init__(self):
		         self.num_eyes = 2
		  def breathe(self):
				print("Inhale, exhale")
	   class Fish(Animal):
           def __init__(self):
		       super().__init__()                                  <- the super refers to the super class, same as Animal.__init__(self)
		   def swim(self):
		       print("moving the fish")
		   def breathe():
		       super().breathe()                                    <- calls the super classes method
			   print("doing this underwater")
	  nemo = Fish()
	  nemo.swim()
	  nemo.breath()
   
Accessing methods of the objects:
------------------------------------------------------------
   - we can acces a metod of a class with classname.function()
   ex. class Person:
		 def speak(self)
		    print("aloha") 
	   p1 = Person()
	   p1.speak()
	   

Standard built in inheritable methods for objects (dunder functions):
--------------------------------------------------------------
   - are inheritable methods that can be override 
   - __str__() - we can return a custom string when when str(objectname) is called:
   ex. def __str__(self):
	    return "the class is myclass"
		
   - __len__() - we can specify what returns the len(object) function :
   ex. def __len__(self):
	   return 5

   - __abs__() - we can define what will the absolute value return on the object defined:
   ex. def __len__(self):
	   return 5
   
   - dir() - we can find all of the dunder methods defined on a class(by default and theones we defined):
   ex. print(dir(object))
   
   - __call__()  - we can call the object like a function and it returns or not what this function does:
   ex. class Monster(object):
		  __call__(self):
			print("object was called!)
		a = Monster();
		a()                                    <- object was called 
	
   - __add__()  - we can add  to the object and the summ is defined through __add__:
   ex. class Monster(object):
         objvalue = 12   
         __add__(self, something):
             return self.objvalue+something
       a = Monster()
	   print(a+5)	                              <- 17	   
										 
   ex. len(p1)               <- p1.__len__()
        print(p1 is p2)      <- p1.__eq__(p2)           test de egalitate de identitate
		print(p1)            <- __str__()            <- returns a string representation of the object by  defining __str__() and returning a string
		del(p1)              <- __del__()            <- def __del__(): print("object deleted")
    the eq function could look like this:
	def __eq__(self, second):
	    return (self.nume==second.nume and self.varsta==second.varsta)
		
		
   class Circle:
		def __lt__(self, second):              <- defining the less then function like comparison operator
			return self.radius<second.radius
			
        def reportsort:
			return sorted(self)                <- this needs the __lt__ function for sorting to be defined
			form:Shape.Circle                <- anotation, helps python to know what is form
			
Method types:
------------------------------------------------------------------
   - classmethods are built in decorators that that receives the class as an implicit first argument .
   - class methods are bound to the class and not the object of it
   - they have acces to the state of the class as it points to the class and takes a class parameter that points to the class
   - it can modify a class state that that would apply across all the instances(objects) of the class.ex it can modify a variable that will be apliable to  all the objects
   - class methods are used to create factory methods.A factory method returns class objects
   ex. class C(object):
		@classmethod
		def fun(cls, arg1,...)
			return "class method called", cls
	- static methods not receive implicit first argument .A static method is also a method that is bound to the class and not the object of the class 
	- static methods cant modify the class state and they dont know anything about the class state
	- static methods are utility type methods.They not operate with the classes data
	
	ex. class C(object):
		@staticmethod
		def get_max_value(x, y):
			return max(x, y)            <- not operates with the classes variables
decorators:
-----------------------------------------------------------------------
   - decorators are functions that add extra functionality to functions.  Essentialy wrappers that add extra code:the decorator returns a function defined in itself that executes the passed function and extra code
   Ex. def uppercase_decorator(func):
          def wrapper():
            result = func()
            return result.upper()
          return wrapper
       @uppercase_decorator                       <- tells python through wich decorator function will be  passed like function argument and called
	   def greet():
		  return "hello"
       print(greet())  # Output: HELLO            <- when greet will be called it will call it through the decorator function like a function pass by argument

   - we can have multiple decorators defined on afunction:
   ex. def uppercase_decorator(func):
          def wrapper():
            result = func()
            return result.upper()
          return wrapper
	   def printme(func):
		 def wrapper(func)
	       print("this decorator")
		   func()
		 return wrapper
       @uppercase_decorator                       <- tells python through wich decorator function will be  passed like function argument and called
	   @printme                                   <- when called greet() the uppercase_decorator will be run then the printme
	   def greet():
		  return "hello"
       print(greet())  # Output: HELLO            <- when greet will be called it will call it through the decorator function like a function pass by argument
	   
	- we can call decorators with arguments:
	ex. def decorator(func):
	        def wrapper(wrapperparameter):                     - could be def wrapper(*args,**kwargs):  <- can pass multiple parameters, the decorator works with any function
			   print(f"Decoration, {wrapperparameter}")
			   func(wrapperparameter)
			return wrapper
	    @decorator
		def myfunc(a)
	       print(f"First function{a}")
		   
    - we can call a decorator multiple times:
	ex. def repetition_decorator(repetitions):
	       def decorator(func):
		      def wrapper():
			     for r in range(repetitions):
				     func()
			  return wrapper
            return decorator
        @repetition_decorator(5)
        def func():
          print("Function")
       #func = repetition_decorator(4)(func) this is what it is called
       func()	   
		   
@property decorator:
-----------------------------------------------------------------------
   - @property allows to turn methods into attributes - the pythonic way of makeing getters and setter and deleters
   - the property decorator is a built-in function that creates and returns a property object.allows python getter and setter methods to be called like variables:
   - property(fget=None, fset=None, fdel=None, doc=None)               <- fget getter function, fset setter function, fdel deleter function
   - getter methods are used with the @property decorator:
   ex. class Student:
		def __init__(self, first_name):
			self._first_name = first_name             _first name is private (by convention)
		@property                                    <- indicates that it will be run through @property decorator alias property function
		def get_name(self):
			return self._first_name
			
		@get_name.setter
		def get_name(self,name):
			self._first_name = name
		
		@get_name.deleter
		def get_name.deleter:
			del self._first_name
	  
	  student = Student("Monica")
	  print(student.get_name)             <- no () like a function would be called . if student.get_name() would give error
	  student.getname = "Andras"          <- sets the name to Andras
	  del.get_name
	  
	  
	- setter methods are set with the @<property_name>.setter syntax where property_name is the name of the property the setter is for:
	ex. class Person:
		def __init__(self, name, age):
			self._name = name
			self._age = age
		@property
		def name(self):
			return self._name
		@name.setter
		def name(self, value):
			self._name = value	
	  person = Person("Alice", 30)
	  person.name = "Bob"
	- property deleter is a decorator used to delete class variables:
	- It is defined using the @<property_name>.deleter decorator where <property_name> - name of the class variable to delete
	ex. class Person:
			def __init__(self, name, age):
				self._name = name
				self._age = age

			@property
			def name(self):
				return self._name

			@name.deleter
			def name(self):
				del self._name

		person = Person("Alice", 30)
		print(person.name)  # "Alice"
		del person.name
		print(person.name)  # AttributeError		

polymorphism
------------------------------------------------------------
   - we can have compile time polymorphism: it works by passing an object to a function and calling a function of the object that has to be with the same name 
    ex. class employee():
       def name(self)
	     print("Tibi is his name)
	   def salary(self)
	     print("his slary is 350")
      class employee2():
        def name(self)
	      print("Zoli is his name)
	    def salary(self)
	      print("his slary is 250")
      def func(obj):
          obj.name()
		  obj.salary()
	
	  objemp=employee()
	  objemp2=employee2()
	  func(objemp)
	  func(objemp2)
	- we can have runtime polymorphism:
	ex. class employee():
          def __init__(self, name,age):
               self.name=name
               self.age=age
          def earn (self):
               pass
        
		class childemployee1(employee):
           def earn(self):    runtime polimoprphism
                print(:no money")
        
		class childemployee2(employee):
           def earn(self):    runtime polimoprphism
                print(:has money")
        c=childemployee1
		c.earn(employee)                     <- acces the function from the parentclass, error if not
		d=childemployee2
		d.earn(employee)                     <- acces the function from the parentclass

Method override:
-----------------------------------------------------
   - we can override methods in the child class naming the method with the same name:
	ex. class Parent():        
			def show(self):
				print("Inside Parent") 
		class Child(Parent):         
			def show(self):
				print("Inside Child")
				
	- we can acces the super class method from the overide method with super() keyword:
	ex. class Parent():        
			def show(self):
				print("Inside Parent") 
		class Child(Parent):         
			def show(self):
				super().show()
				
	- we can acces the super class method from the override method with the name of the parent class:
	ex. class Parent():        
			def show(self):
				print("Inside Parent") 
		class Child(Parent):         
			def show(self):
				Parent.show()                         <- parent class name
				
	- we can raise an error if a parent class method was called and we did not intend the parent class method to be called 
	  instead the method beeing overrided in the child class
	  Ex. class Animal():
			def speak(self):
				raise NotImplementedError("Subclass must implement method!")
		  d = Animal()
		  d.speak()                   <- raises the error
				
encapsulation:
-----------------------------------------------------
   - encapsulation means makeing members private
   - we can make a member variable with double __ in front private:
   ex. class maxearn():
         def __init__(self):
		        self.__maxearn=10
	     def earning(self):                        
		     print(f"earning: {self.__maxearn}")
	     def setmaxearn((self, earn):              <- setter method
		     self.__maxearn=earn
			 
abstraction:
------------------------------------------------------
  - we can abstractize the methods of a class with a pass
  - the subclasses needs to implement the parent class abstract method:
  ex. class employee(ABC):
         def emp_id(self, id, name, age):         <- abstraction
		     pass
	  class childemployee(employee)
	     def emp_id(self, id ):                    <- partialy implemented in the child class
		     print("emp_id is ")
			 
math module:
-------------------------------------------------------
   ex. import math
       x=min (15, 10,20)
       x=abs(-7.2)    <- absolute number (it returns the positive number of the number getting rid of the -)
       x=pow(3,4)
       x=math.sqrt(64)
       x=math.floor(z)             <- rounds the number down to an integer i<= z
	   x = math.ceil(z)            <- rounds the number up to the first integer
	   x = math.round(4.35)        <- rounds to the most closest integer (up or down)
	   x = math.pi                 <- 3.1415926
	   x = math.inf                <- inf
	   x = math.nan                <- not a number
	   x = math.log(math.e)        <- 1         e is 2.71
	   x = math.log(100,10)        <- 2
	   x = math.sin(10)              
	   math.radians(180)           <- 3.14926

collections module:Counter
-------------------------------------------------------
		- we can count how many times occur distinct elements in an iterable. it returns a dictionary with the key beeing the elements and value beeing the occurence count:
		Ex. from collections import Counter
			mylist = [1,1,1,2,33,3,,3,3,3,4,4,55]
			sentence = "How many times  does each word show up in this sentence?"
			letters = "aaaaabbbbbbbbbb"
			c = Counter(mylist)                 			-> Counter({1:3, 2:1,3:4, 33:1, 4:2,55})
			c = Counter(sentence.lower().split())           -> Counter({"a":1, "does":1,"how":1,.......})
			c = Counter(letters)                            -> Counter({"a":5,"b":10})
			c.most_common(x)                                -> returns x element with most ocurences in descending order
			list(c)                                         -> returns a list of unique elements from the collection
  
event listeners:
-------------------------------------------------------
   - keyboard event listeners work by passing the key type that will be pressed  and a function that will be triggered when the key was pressed
   
working with CSV files:
--------------------------------------------------------
   - we can easily work with csv files in python by importing the csv module.for working with excel files -> openpyxl library,to work with google sheets -> google sheets python API
   ex. import csv
   
   - we can read in a list from a csv file with the csv.reader().
   ex. import csv  
       with open ("file.csv","r", encoding = "utf-8") as data file:
	   data = csv.reader(data_file)
	   data_lines = list(data)             <- the result is a list in a list where the lists first element is a list with the tablenames.
	   temperatures = []
	   print(data_lines[0])                <- the first element is a list with the tablenames
	   print(data_lines[1][2])             <- shows the third element from the first list
	   for row in data_lines:
	      if row[1] != "temp":             <- it takes the second element in every row that will corespond to the respective table name
			temperatures.append(row[1])
	   print (temperatures)
	   
	- writer() - we can write to a csv file with writer function:
	ex. with open ("to save.csv", mode = "w", newline = "") as fileoutput:             <- with "w" mode we overwrite the file, for adding new lines "a" for append
	    csv_writer = csv_writer(fileoutput, delimiter = ",")
		csv_writer.writerow(["a","b","c"])                    <- it writes a single row to the file, number of elements shoul match the number of elements in a row(3 columns = 3 values)
		csv_writer.writerows([["1","2","3"],["4","5","6"]])   <- it writes 2 rows to the csv file, the number of elements in a row needs to match the number of columns in the table

working with pdf files in python:
----------------------------------------------------------
   - a scanned image in a pdf file cannot be read by python as well tables
   - we can work with pdf files by installing and importing PyPDF2 library.there are multiple libraries that work with PyPDF2, some payed
   - working with pdf files resumes just to read the data from it, this library does not support full writing functionality
   - ex. pip install PyPDF2
   ex. import PyPDF2
       with open ("mypdf.pdf","rb") as myfile:                   <- read binary mode
	   pdf_reader = PyPDF2.PdfFileReader(myfile)
	   
   - numPages -  we can see how many pages does have the document:
   ex. import PyPDF2
       with open ("mypdf.pdf","rb") as myfile:                   <- read binary mode
	   pdf_reader = PyPDF2.PdfFileReader(myfile)
	   pdf_reader.numPages
	
	- getPage() we can grab any page from the file .result is a string where lines are separated by \n:
	ex. import PyPDF2
       with open ("mypdf.pdf","rb") as myfile:                   <- read binary mode
	   pdf_reader = PyPDF2.PdfFileReader(myfile)
	   page_one = pdf_reader.getPage(0)
	   page_one_text = page_one.extractText()                    <- extracts the text from the first page .the result is a string where lines are separated by \n
	
	- PdfFileWriter() - we can write to a pdf file .What we want to write needs to be a PyPDF2.pdf.PageObject
    ex. import PyPDF2
        with open ("mypdf.pdf","rb") as myfile:	
			pdf_reader = PyPDF2.PdfFileReader(myfile)
			page_one = pdf_reader.getPage(0)
			pdf_writer = PyPDF2.PdfFileWriter()
			type(page_one)                                    <- PyPDF2.pdf.PageObject
			pdf_writer.addPage(page_one)
		with open ("pdfoutput.pdf","wb") as pdf_output:   <- opens the file in write binary mode 
			pdf_writer.write(pdf_output)
	
   
   
   
pandas:
----------------------------------------------------------
   - we can use the functions in pandas we can import pandas library:
   ex. import pandas                <- we may not have it and needs to be installed
   
   - readcsv() we can read datas from a csv file with pandas.read_csv() function:
   ex. data = pandas. read_csv("filename")                     <- puts all the data in a table with indexpositions(if it was saved), tablenames, etc
   
   - [] we can acces a tablename from the table with the [] or with table.tablename
   ex. print(data["temp"])              <- outputs all the elements of the tablename temp  - dictionary type of adressing
   ex. print(data.temp)                  <- object type of adressing
   
   - we can acces the elements of the elements in a json converted file with the []:
   ex. data["temp"][0]["location"][1:12:2]       <- slice notation from 1 to 12 with step 2
   
   - we can convert a json object to a pandas dataframe:
   ex. from pandas import json_normalize
       mydataFrame = json_normalize(jsonlist)
	   
   - .keys() we can find all the keys of the Dataframe:
   ex. keys = dataframe.keys()
   
   - a panda structure can be 1 dimensional, or 2 dimensional data
      - 1 dimensional are Series
	  - 2 dimensional are DataFrame
   
   - the data type of the panda structure is DataFrame  (list of dictionary kinda)
   ex. data = pandas. read_csv("filename")
       print(type(data))      <- DataFrame object type    
	   
   - the data type of a table from the DataFrame is a Series type of object:( a list kinda)
   ex. print(type(data[1]))                    <- Series type of data
   
   - the pandas library allow to convert a panda to any data type (DataFrame.to_parquet, to_pickle, to_csv, to_hdf, to_sql, to_dict, to_excel, to_json, to_html, to_feather, to_latex, etc)
   
   - to_list() to convert from a panda table column Series, we can with the to-list() method
   ex. print (data["temp"].to_list())                          <- this convert the panda t a list
   
   - pandas have built in math functions for mean, square, largest, median, etc:
   ex. a= data[0].mean()
   
   - if we want to acces all the row  in the Series:
   ex. print(data[data.day == "Monday"])           <- have acces to all the other elements of the row that has Monday in the day column
       print (data[data.temp==data.temp.max()]
	   
   - we can create a DataFrame object with a dictionary as argument:
   ex. data_dict = {"student":["Amy","Feri","Tibi"], "scores:":[76,56,65]}
       data = pandas.DataFrame(data_dict)            <- we create the panda by creating a dataFrame object with a dictionary as argument
	   
   - data.to_csv() we can save our DataFrame to a csv file:
   ex. data.to_csv("new_data.csv", index = False)                 <- new_data.csv file where we want to save the DataFrame index=False                        
                                                                     does not write the index of every line to the file
   
   - len() we can find how many elements are in a result in the DataFrame:
   ex. squirelcount = len(data[data["Primary Fur color"] == "Gray"])     <- all the elements that contains in the Primary Fur color column the gray element
   
   - iloc[] we can acces a row in a DataFrame with the iloc[pos] if dataframe is a list we can acces row and column
   ex. datarow = data.ilok[0]                <- we can acces all the elements of the first dictionary
   ex. datarow= data.ilok[0][1] 
   
   - iterrows() we can iterate over a Pandas DateFrame with iterrows():
   ex. import pandas
       student_dict = dict {"student":["Angela", "Tibi"], score:[15,13]}  
       for (key,value) in student_dict.items():      <- classsic iteration with a for
          print(value)   
       studentdataframe = pandas.DataFrame(student_dict)
	   #loop through rows of a data frame:
	   for (index,rows) in student_data_frame.iterrows():
	       print(rows.student)                           <- or rows["student"]
   - loc() we can add new rows to a DataFrame with the loc function:
   ex. import pandas
       database = pandas.read_csv("birthdays.csv")
       listofnames=[["Test","test@email.com",1961,12,21],["Anna","anna@gmail.com", 2018,10,21],["Andra","gruia@gmail.com",1982,3,24]]
       for i in listofnames:
          database.loc[len(database)]=i
       database.to_csv("birthdays.csv", index=False, header=False)
   - 
       	   
Graphical user interfaces with tkinter:
------------------------------------------------------------------------------
   - we can find tkinter related information on tcl.tk  
  - we can invoke the graphic user interface with tkinter
   ex. import tkinter
       window = tkinter.Tk()         <- invoke the windows creation
	   windows.config(background = "Red")
	   ..............
	   window.mainloop()             <- this has to bee the last line in the program, before it comes al the code
   
   - title() we can set the title of a window with title()
   ex. window=tkinter.Tk()
       window.title("Title of the window")

   - minsize() we can set the minimum size of a window:
   ex. window=tkinter.Tk() 
       window.minsize(width = 500, heigth = 300)
	   
   - we can change the tkinter logo with wm_iconbitmap("logofile.ico")
   ex. window.wm_iconbitmap("myicon.ico")
   
   - pack() the geometry manager organizes widgets in blocks before placing them in the parent widgets
   - syntax:
   ex. widget.pack(pack options)                <- pack options are **kwarg,we have to specify the key value pair
         options : - expand  - when set to tru the widget expand to fill any space that it can fill
		           - fill - Determines whether widgets fill any extra space alocated by the packer.
				     NONE(default), Y fill horizontaly, Y - fill vertically, BOTH - fill X and Y
				   - side - determines which side of the parent widget packs aginst:TOP, BOTTTOM, LEFT, RIGHT
				   
	- we can acces the properties of the widgets in 2 ways:
	   - the dictionary way:
	   ex. mylabel["text"] = "My button"
       - through the config method:
       ex. mylabel.config(text = "new button")
	   
padding in tkinter(making a space around an element or window border where nothing comes:
--------------------------------------------------------------
   ex.window=tkinter.Tk()
       window.config(padx=100,pady=100)            <- safespace from the border of the window 
       label.config(padx=50,pady=20)
	   
Label in tkinter:
-----------------------------------------------------------
   - Label() - we can give a label to the window:
   ex. mylabel = tkinter.Label(text = "I am a label",fg = "#45337" font = ("Arial", 24, "bold"),width=29)    <- fg foreground color, 24 is size 
                                                                                                       <- width makes the widget this width, centering text
	   mylabel.pack(expand = True)
	   
   - we can change the properties anytime of the element with the .config(options)
	   
Buttons with TKinter:
--------------------------------------------------------------
   - we can create a button with tkinter:
   ex.import tkinter
       def functionnametobecalled:
		print("i got clicked")
      mybutton = tkinter.Button(framename,text = "Klick me!", command = functionnametobecalled)             <- command calls the functioname when clicked on it
	  mybutton.pack(anchor = CENTER)                                    <- puts the button in the center of the frame
   - we can change the label after the creation with 
   ex. mybuton.config(text="fgdF")
   
   ex. from tkinter import *
       class MyButtons:
        def --init--(self, rootone):
          frame=Frame(rootone)
          frame.pack()
          self.printbutton=Button(frame,text="Click here", command=self.printmessage)
          self.printbutton.pack()
          self.quitbuttton=Button(frame, text="Exit", command=frame.quit)                         /frame.quit  kimehy a windowbol
          self.quitbutton.pack(side=LEFT)
        def printmessage(self):
          print("Button clicked")
        root=Tk()
        b=MyButtons(root)
        root.mainloop()
	
	- we can pass a tkinter variable to the command button:
	ex. def def printvalue(mytkinterstring):
          def inner():                         <- command = printvalue(mytkinterstring) <- needs to return something, that is why it returns the inner function, otherwise it will not execute
             print(mytkinterstring.get())
             print("button was pressed!")
          return inner
	    mytkinterstring = tk.StringVar(value = "")
		oneentry = tk.Entry(master = window, textvariable = mytkinterstring )
		oneentry.pack()
		onebutton = tk.Button(master = window, text = "Button", command = printvalue(mytkinterstring))    <- passes to the function the tkinter var StringVar as argument to the command function.it represents the entry field value
		onebutton.pack()                                                                                     the smae can be done with command = lambda:printvalue(mytkinterstring) 
		
   - we can change the properties anytime of the element with the .config(options)
   
   - we can put an image on a buton:
   ex. my_image = tkinter.PhotoImage(file = "pathtofile/file.png")
       mybuton = tkinter.Button(Image = my_image, highlighttickness=0)
   
Entry with tkinter:
--------------------------------------------------------------
   - The Entry widget is used to accept single-line text strings from a user.
   - we can have an entry window where we input data:
   ex. import tkinter
       myentry = tkinter.Entry(framename,width = 20)           <- the frame or window where it belongs
	   myentry.pack()                                <- needed to put it on the window, otherwise does not apear
	   
   - we can get the text in the entry with the get function:
   ex. myentry.get()
   
   - we can change the properties anytime of the element with the .config(options)
   - we can hve a blinking cursor in it with the focus() method:
   ex. myentry.focus()
   -.insert(index, text) we can insert a text in the entry that will be in the box(email sign in a email box): index can be 0, END
   ex.myentry.insert(0, "aloha@aloha.com") 
   
   - .delete() we can delete the content of the entry with delete:
   ex. myentry.delete(0,END)                                      <- deletes an entry from index 0 to index END

Text with tkinter:
--------------------------------------------------------------
   - we can define a text box for multiple line entering:
	ex. text = Text(parrentwindowname, height = 5, width = 30)                 <- textbox propertys height and width in character number and lines
	
	- we can put a cursor in the textbox for imediate typing:
	ex. text.focus()                                            <- puts cursor in textbox
    
	- our text can have some text already typed in:
	ex. text.insert(END, "Example of multiline text entry")
	
	- get() we can get the text in the textbox:
	ex. text.get("1,0", END)               <- get the current value in the textbox at line 1, character 0, until the END of the textline
	
	- we can change the properties anytime of the element with the .config(options)
	
spinbox and combobox in tkinter:
-----------------------------------------------------------
   - we can have a spinbox.we need a list and assign to the value property of the spinbox
   ex. spinbox = tkinter.Spinbox(parentwindow,from_=0 to=10, width=5, command=spinbox_used)        <- command - a function that is executed.it is passed asa reference, it will get automaticaly executed
       spinbox.pack()
	   
   ex. def getpos(a):
		 def b():
            print(a.get())
         return b

	   window = tk.Tk()
	   window.title("This")
	   mytkinterstring = tk.StringVar(value = "")
	   combox = tk.Spinbox(master = window,textvariable = mytkinterstring, command = lambda event:print("up") )
	   combox.configure(values = ("12","13","14"))          <- or combox["values"] = ("12","13","14")
	   combox.pack()
	   combox.bind("<<Increment>>",getpos)                    <- gets triggered when we raise the value with the arrow up
	   combox.bind("<<Decrement>>", lambda event: print("up")) <- gets triggered when the value is lowered through the arrow down
	   window.mainloop()
	   
   - get() we can get the value from a spinbox:
   ex. print(spinbox.get())
   
   - we can change the properties anytime of the element with the .config(options)
   - we can have a combobox: combobox = tk.Combobox(master, option=value,...) it is a dropdown menu with selectable items .We need a list to assign to the values property ofthe combobox
    ex. import tkinter as tk
	    window = tk.Tk()
		window.geometry("600x400")
		stringvar = tk.StringVar(value = "1")
		myentry - ttk.Entry(master = window, text = "This is an entry")
		items = (' January',' February',' March',' April',' May',' June',' July')
		monthstring = tk.StringVar(value = items[0])                  <- equals the first element in the list
		combo = ttk.Combobox(window, textvariable = monthstring)
		combo["values"] = (' January',' February',' March',' April',' May',' June',' July')   <- assign the dropdown list elements
		combo.configure(values = items)                                     <- this line same as the above
		combo.pack()
		combo.bind("<<ComboboxSelected>>", lambda event: print("test"))     <- this is how trigger an event when item from  combobox is selected
		combo.bind("<<ComboboxSelected>>", lambda event: myentry.config(text = f("This is the {stringvar.get()})))
  
checkbuton in tkinter:
-----------------------------------------------------------
   - we can have a checkbuton in tkinter
   ex. checkbutton = tkinter.CheckButton(parentwindow, text=="is on?", variable = checkedstate, command = checkbutonused)  <- checkbutonused a function that will be executed
       checkbutton.pack()                                                                                               variable = checkedstate   <- chackedstate is  0 or 1
   ex. check_var = tk.IntVar()                      <- tkinter variable object. can be BooleanVar for true or false
       check = tk.Checkbutton(window, text = "a check", command = lambda:print(check_var.get()), variable = check_var, onvalue = 10, offvalue = 5 )	     <- Checkbutton has a "variable" tkinter variable that can be assigned to a 
	                                                                                                                                                      Tkinter variable, onvalue is the value that is returned when check is on	  
   - get() we can get the state of the checkbuton with the get ()
   ex. a = checkbutton.get()
   
   - deselect() we can deselect the checkbuttton:
   ex.checkbutton.deselect()
   
   - invoke() we can call this method that does the same action like a user clicked on the checkbutton
   ex. checkbutton.invoke()
   
   - we can change the properties anytime of the element with the .config(options)
   
radiobutton in tkinter:
----------------------------------------------------------
   - we can have a radiobutton in tkinter.it does not have a .get() function to get its value, instead tkinter variable is needed like IntVar() or other
   ex.  def button_func()
	       print(string_var.get())
        mainwindow = Tk()
		comonboolean = tk.BooleanVar(value = True)
		commonstringvar = tk.StringVar(value = "A")
		radiostate = tkinter.IntVar(mainwindow)
		radiobutton = tkinter.Radiobutton(mainwindow,text="Option1", value=1, variable = radiostate, command=radio_used)   <-in radiostate IntVar will be  saved which button is clicked.if radiobutton1 is integer and 2 is string then StringVar 
       radiobutton2 = tkinter.Radiobutton(mainwindow,text="Option2", value=2, variable = radiostate, command=radio_used)   <- the radio buttons need to have different values, otherwise all will be selected
	   radiobutton.pack(anchor = W)
	   radiobutton2.pack(anchor = W)
	   	def radio_used:
		   print(radiostate.get())         <- print out which buton is pressed
		   
	ex. def printvalue():
           print(commonstringvar.get())
	    comonboolean = tk.BooleanVar(value = True)     <- boolean tkinter variable used to demark the state of the checkbutton if it is on or off
		commonstringvar = tk.StringVar(value = "A")    <- tkinter variable to hold  the value of the radio button group which one is active
	    radio1 = tk.Radiobutton(master = window,text = "radio 1", value = "A",command = lambda:print(comonboolean.get()) , variable = commonstringvar )    <- if clicked it will print out the value of the checkbox(True/False)
		radio1.pack()
		radio2 = tk.Radiobutton(master = window,text = "radio 2", value = "B",command = lambda:print(comonboolean.get()), variable = commonstringvar )     <- if clicked it will print out the value of the checkbox(True/False)
		radio2.pack()
		checkbtn = tk.Checkbutton(window,text = "a check", onvalue = 1, offvalue = 0 , command = printvalue, variable = comonboolean)                      
		checkbtn.pack()

   - radio buttons are connected through the same variable=samevar tkinter variable.this ensures that if one clicked, the status of the others are unticked, however value=something has to be different, 
     otherwise they both will be checked or unchecked	   
   - we can get the state of the radio button: 
   ex. print(radiostate.get())
   
   - we can change the properties anytime of the element with the .config(options)
   
Listbox in tkinter:
----------------------------------------------------------
   - we canhave a listbox in tkinter:
   ex. listbox = tkinter.Listbox(masterwindow, height = 4)
       fruits = ["Apple","pear","orange"]
	   for item in fruits:
		listbox.insert(fruits.index(item), item)
	   listbox.bind("<<ListboxSelect>>", listbox_used)
	   listbox.pack()
	- we can change the properties anytime of the element with the .config(options)

Scale in tkinter:
---------------------------------------------------------
   - we can have a scale in tkinter : it returns a value if we release the mouse
   ex. def scaleused(value):
			print(value)
		scale = tkinter.Scale(masterwindow, from_=0, to =100, command=scaleused))   <- scaleused is a function that gets called when used, 
		                                                                         master represents the master window
		scale.pack()
   - we can get the return value of the scale:
   ex. scale.get()
   
   - we can set the scales value:
   ex. scale.set(value)
   
   - we can change the properties anytime of the element with the .config(options)

menus or  dropdowns in tkinter:
---------------------------------------------------------
   ex. from tkinter import *
       def function1:
         print("Menu item clicked")
       root=Tk()
       mymenu=Menu(root)
       root.config(menu=mymenu)      /tells the root windows who is the menu
       submenu=Menu(mymenu)          /tells that the manu has a submenu
       mymenu.add_cascade(label="File", menu=submenu)
       submenu.add_command(label="Project", command=function1)
       submenu.add_command(label="Save", command=function1)
       submenu.add_separator()
       submenu.add_command(label="Save", command=function1)
       newMenu= Menu(mymenu)
       mymenu.add_sascade(label="Edit", menu=newmenu)
       newmenu.add_command(label="Undo", command=function1)
       root.mainloop()
	   
toolbar in Tkinter:
---------------------------------------------------------
    ex. from tkinter import *
        def function1:
          print("Menu item clicked")
        root=Tk()
        toolbar=Frame(root, bg="pink")
        insertbutton=Button(toolbar, text="Insert Files", command=function1)
        insertbutton.pack(side=Left, padx=2, pady=3)
        printbutton=Button(toolbar, text="print", commmand=function1)
        printbutton.pack(side=LEFT, padx=2,pady=3)
        toolbar.pack(side=TOP, fill=X)
        root.mainloop()

Status bar in tkinter
---------------------------------------------------------
   ex. from tkinter import *
       root=Tk()
       status=Label(root,text="this is a status",bd,1,relief=SUNKEN, ancor=W)            /status bar=label glued to bottom
       status.pack(side=BOTTOM,fill=X)
       root.mainloop()
	   
tkinter Menu:
--------------------------------------------------------
   - every toplevel window can have only one menu bar
   - we can add a menu in tkinter:
   ex. from tkinter import *
	   mainwindow=Tk()
	   menubar=Menu(mainwindow)                                    <- creates a Menu
	   filemenu=Menu(menubar,tearoff=0)                            <-create a filemenu whos container is menubar, tearoff means no dashed line!!!!
	   filemenu.add_command(label="New", command = newmethod)      <- add elements to the menu
	   filemenu.add_command(label="Open", command = openmethod)
	   filemenu.add_command(label="Save", command = savemethod)
	   filemenu.add_separator()
	   filemenu.add_command(label="Exit", command = mainwindow.quit()
	   menubar.add_cascade(label="File", menu=filemenu, underline=0)     <- add the filemenu and its elements to the manubar container,
	                                                                        underline means it can be accesed with a shortcut, specifies which character in pos to be underlined
	   editmenu=Menu(menubar, tearoff=0)                                <- tearoff means no dashed line (detach menubar) apears in the menu
	   editmenu.add_command(label="Undo", command = undomethod)
	   editmenu.add_command(label="Redo",command = redomethod)
	   menubar.add_cascade(label="Edit",menu=editmenu, underline=0)
	   submenu = Menu(filemenu, tearoff=0)                               <-creates submenu with parent not main manu but the menu where it apears
	   submenu.add_command(label="Color Themes")
	   filemenu.add_cascade(label="Preferences", menu=submenu)           <-add submenu to filemenu and links it to filemenu
	   
tkinter layout managers: pack, place and grid
--------------------------------------------------------
   - just one manager can be used in a program
   - pack manager: packs each of the element next to each other in a logical manner - by default from up to down
        -hard to position something precise
      ex. label.pack(side = "left")      <- packs everything from left to right
   
   - place manager: permits the positioning much more precise of the elements
	  ex. label.place(x=0,y=0)                         <- positions the element at 0,0 position
	  
   - grid manager: positions the element oon a grid.the window is split on rows and columns and positions the elements on the row,column
     coordonates
		ex. mylabel.grid(column=3,row=2,columnspan=2, rowspan = 5, sticky="W")           <-columnspan means how many columns it will stretch
																			  - rowspan means how many rows it will span
               - sticky() we can position inside a grid cell with sticky  
                label.grid(row=10, column=10, sticky="w", padx=10, pady=10)    <- positions to the left side of the grid cell(default is center), 
				                                                                  padx,pady makes spaces in pixals before and after the widget, up or down			   
		
tkinter Canvas widget:
--------------------------------------------------------
   - canvas allows to layer one widget over an other widget
   ex. from tkinter import *
        window= Tk()
		window.title("Hey")
		window.config(width=100,heigth=50, bg = "#e65743",padx=20,pady=20)     <- hexa for the color,padx,pady space where nothing comes
        mycanvas = Canvas(width = 200, heigth = 200,bg="#5467763",highlighttickness=0)      <- width and heigth in pixel
		imagevar = PhotoImage(file="tomato.png")      <- PhotoImage is a tkinter format that can read an image file and return it in python
        myimage = mycanvas.create_image(100,122,image=imagevar)       <- creates an image on the canvas places it to 100,122 with center of the image like anchor
		myimage = mycanvas.create_image(0,0,anchor="nw",image=imagevar)   <- creates an image on the canvas,
                                                                		places it to 0,0 with the uper left corner of the image as anchor
		mmytext = mycanvas.create_text(100,112,text="yuhuuu",fill="white",font=("Arial",35,"bold"), width = 100)      <- fill - color in the background of the text
		mycanvas.pack()                                                                                                  width is the text box width where the text will be fit
   - we can create a rectangle on the canvas:
   ex. canvas = tk.Canvas(master = window, bg = "white")
       canvas.create_rectangle((50,20,100,200), fill = "red", width = 10)             <- needs a tuple that represents the uper left and the lower right coordinates
   - we can create a line 
   ex. canvas.create_line((0,0,100,200), fill = "yellow")
   
   - we can create an oval or a circle
   ex. canvas.create_oval((0,0,100,150), fill = "blue")
   
   - we can create a polygon:
   ex.canvas.create_polygon((0,0,100,150,300,50), fill = "green")

   - we can create an arc:
   ex. canvas.create_arc((0,0,100,150), fill = "blue")   
   
   - we can create text:
   ex. canvas.create_text((0,0), text = "this is a text", fill = "green", width = 10)
   
   - we can display widgets on the canvas:
   ex. canvas.create_window((50,100), window = ttk.Label(window, text = "this is a text"))
   ex. canvas.create_window((50,100), window = ttk.Button(window, text = "this is a button"))   
   
   - we can bind an event to the canvas to do things:
   ex. def draw_on_canvas(event):
         x = event.x 
		 y = event.y
		 canvas.create_oval((x-brushsize/2, y-brushsize/2, x+brushsize/2,y+brushsize/2)
       brushsize = 2
	   canvas.bind("<Motion>", draw on canvas)
   
   - whenever we add something to the canvas, we need to specify position , middle is the position	where x and y are considered
   - itemconfig() we can modify the atributs of any widget placed on a canvas with the itemconfig()	
	ex. mycanvas.itemconfig(mytext, text = "hulla")                      <- mytext is the widget name placed on a canvas, , text is the property changed
	- by default when an image is placed the center of the image is taken when placeing as coordinate
	- to specify  the upperleft corner of the image when placing we can use the anchor():
	ex: self.canvas.create_image(0, 0, image=self.image, anchor="nw")           <- anchor="nw" means that when placing the image the upper left corner shouldbe placed at the coordinates

.after() widget property:
---------------------------------------------------------
   - .after() we can use the .after() property on a widget that waits for an amount of time and then gives a command to execute something:
   ex. import tkinter
       window = tkinter.Tk()
	   timerpause = window.after(1000,dosomething,*args)       <- dosomething is a method name that will be called, *args is an argument list that
                                                 	              will be passed to the function(can be used on main window or any other widget that needs it)
	   def dosomething(a):
			print(a)
   - .after_cancel()we can cancel the timer setup with the cancel method:
   ex. window.after_cancel(timerpause)                         <- timerpause is the variable that the after was assigned
   
messagebox in tkinter:
----------------------------------------------------------
   - messagebox is defined in tkinter:
   ex. import from tkinter messagebox
   
   - the folowing methods are defined in the messagebox class:
           showinfo(title=None, message=None, **options): Show some relevant information to the user.
           showwarning(title=None, message=None, **options): Display the warning to the user.
           showerror(title=None, message=None, **options): Display the error message to the user.
           askquestion(title=None, message=None, **options): Ask question and user has to answered in yes or no.
           askokcancel(title=None, message=None, **options): Confirm the users action regarding some application activity.
           askyesno(title=None, message=None, **options): User can answer in yes or no for some action.
           askretrycancel(title=None, message=None, **options): Ask the user about doing a particular task again or not.
	ex. import from tkinter messagebox
	    istrue = messagebox.askokcancel("write","this will be written.Ok or cancel!")
		if istrue:
		   print ("ok was clicked!")

Frame in python:
----------------------------------------------------------
   - we can create a frame in a window with the frame keyword:
   ex. from tkinter import *
       window = Tk()
	   myframe = Frame(window, height=120, width = 180, bg="#234567", bd=1, relief=FLAT)     <- bd = border depth, relief - it does not have rd dimensional
	   myframe.place(x=0,y=0)                         <- x=0,y=0 is the upper left corner of the main window
       window.mainloop()	   
   ex. window = Tk()
       window.geometry("700x480")
       myframe = Frame(window, height=120, width = 180, bg="#234567", bd=1, relief=FLAT)     
       myframe.place(x=0,y=0)  
       myframe2 = Frame(window, height=120, width = 520, bg="#232267", bd=3, relief=GROOVE)     
       myframe2.place(x=180,y=0) 
       myframe3 = Frame(window, height=360, width = 700, bg="#112267", bd=3, relief=RIDGE)     
       myframe3.place(x=0,y=120)                       
	   mybutton = Button(myframe, height = 2, width=5, text="ok", bd=2, relief=raised)    <- we can place a button over a frame (mainwindow can be window, coordonates are relative to masterwindow
	   mybutton.place(x=20,y=20)
	   window.mainloop()

Tkinter variables:
----------------------------------------------------------
   - tkinter has inbuilt variables that work with widgets
   - are automaticaly updated by the widgets
   - they store usualy data, strings and booleans
   - StringVar, IntVar, DoubleVar,BooleanVar - tkinter variable that stores a string, int float or boolean
   Ex. import tkinter as tk
	   def button_func()
	       print(string_var.get())                                            <- will print out the string_var = tk.StringVar object
	   window = tk.Tk()
	   string_var = tk.StringVar(value = "start  value")                      <- StringVar Object, it is initialized with "start  value"
	   label = tk.Label(master = window, text='label', textvariable = stringvar)
	   label.pack()
	   entry = tk.Entry(master = window, textvariable = string_var)          <- label and entry share the same variable string_var. whenever the first changes the variable, the second widget changes also
	   entry.pack() 
	   button = tk.Button(master = window, text = "button", command = button_func, text_variable = }})        <- when button push, it will print out to the console what we entered in the entry
       window.mainloop()

Tkinter events:
----------------------------------------------------------
   - we can have lots of event types like mouse press, mouse wheel, keyboard press, keyboard input, etc
   - we can bind events to a widget:
   ex. Widget.bind(event, function)               <- format: modifier - type - detail     : Alt - Keypress - a
       def functionreferencetobecalled(event):    <- when the functionreference is called after the bind event happened, tkinter expect the functionreference have an argument, and it will pass the "event" parameter to it
	       print (event.char)                     <- it will show the key pressed
	   window = tk.Tk()
	   window. bind("<Alt-KeyPress-a>", lambda event: print(event))            <- binds to the main window the the Alt+a key combination. tkinter will automatically insert "event" that is  info about the event to the callable method that is why lambda event 
       window.bind("<KeyPress>") ,functionreferencetobecalled)                 <- functionreferencetobecalled is reference to the function that will be called when an event happened,  the "event" parameter will be automatically passed to the called function.
	   window.pack()                                                              The event will be triggered after any keypress
   ex. def getpos(event):
			print(f"{event.x} - {event.y}")
		def func():
			 window = tk.Tk()
			 window.title("This")
			 mytkinterstring = tk.StringVar(value = "")
			 oneentry = tk.Entry(master = window, textvariable = mytkinterstring )
			 oneentry.pack()
			 window.bind("<Motion>", getpos)    <- getpos is passed as a refernce, it is not called.The line tells python that whenever a mouse move is recorded, call the getpos function and the event is automatically passed to the function when it is called
			 window.bind("<Shift-MouseWheel>", lambda event: print("Mousewheel"))           <- when shift is pressed an mousewheel rotated it will print the message
			 window.mainloop()

Tkinter Tables:
----------------------------------------------------------
   - we can have tables with row and columns.we need lists to populaste the tables:
   ex. window - tk.Tk()
       window.geometry("600,400")
	   firstname = ["Bob","Feri","Edu"]
	   lastname = ["Tibi","Ference", "somogyi"]
	   table = ttk.Treeview(window, columns = ("first","last","email"))
	   table.heading("first", text = "first name")
	   table.heading("last", text = "last name")
	   table.heading("email",text = "email")
	   table.pack()
	   table.insert(parent = "", index = 0, values = ("John","Doe","john@doe.com"))                <- insert an element in the table, parent is usually empty, tells if it goes in an intermediary parent
	   for i in range (0,100):
	     
   
copying to the clipboard:
----------------------------------------------------------
   - to be able to use we need to install pyperclip.
   ex. import pyperclip
       pyperclip.copy(textstring)     <- copies the text to the clipboard
	   pyperclip.paste()              <- returns the text in the clipboard

   - text is pasteable outside and inside of the python progy
	   
smtplib and python(sending mail from python)
--------------------------------------------------------------------
   - SMTP - Simple Mail Transfer Protocol
   - we can send and receive mail from python with the smtplib:
   - the recomended way of sending mail is the one thaat closes the connection imediately:
   ex. import smtplib
       myemail="luky@gmail.com"
	   with smtplib.SMTP("smtp.google.com",587) as connection:                  <- 587 is the port number, 465 could be functional also
		connection.starttls()                         <- makes an ancrypted connection, so if someone intercepts mail , it will be encrypted
       connection.connect("smtp.google.com",465)		<- not necesarily needed?
	   connection.login(login=myemail, password="yyyyyy")
	   connection.sendmail(from_addr=myemail, to_addrs="johny@gmail.com",msg="Subject:Hello!\n\nThis is the message!")  <- message and subject same line, delimited by \n
   
   - we can connet the old way (like read and write in a file) with the SMTP()
   ex. import smtplib
       myemail="luky@gmail.com"
	   connection = smtplib.SMTP("smtp.google.com")
	   c  /n/n mesage start, subject: subjecttitle
	   conneection.close()
   
   - ehlo() - we can greet the server with the ehlo() function
   ex. import smtplib
       smpt_object = smtplib.SMPT("smtp.gmail.com",587)
	   smtp_object.ehlo()                  <- prints 250, smtp.gmail.com at your service....
   - we can read mails with the imap library:
   ex. import imaplib
       M = imaplib.IMAP4_SSL("imap.gmail.com")
       import getpass
       email = getpass.getpass()
       password = getpass.getpass()
       M.login(email.password)
       M.select("inbox")        <- we select the mailbox item (inbox,sent,trash,etc)
       type,data = M.search(None, 'SUBJECT "customsubject"'))	   <- data is the unique id of the mail
       email_id = data[0]
       result,email_data - M.fetch(email_id,"(RFC822)")
       raw_email = wmail_data[0][1]
       raw_email_string = raw_email.decode("utf-8")
       import email
       email_message = email.message_from_string(raw_email_string)
       for part in email_message.walk():
	      if part.get_content_type() == "text/plain':
		     body = part.get_payload(decode=True)
			 print(body)
			 
         	   
   
   - different providers different smtp servers: gmail:smtp.gmail.com, hotmail:smtp.live.com,yahoo:smtp.mail.yahoo.com
   - some providers(yahoo) need special password(generated in the preferences (app password))

Password in Python:
----------------------------------------------------------------------
   - we can work with passwords in Python by importing  getpass library
   ex. import getpass
       password = getpass.getpass("password please:")            <- everything types wild be with *****
	   user = getpass.getuser("user please:")
	   
python date and time module:
----------------------------------------------------------------------
   the datetime.time module deals with the time part, the datetime.date deals with the date part of datetime module
   - we can set the time:
   ex. mytime = datetime.time(13,20,1,20)
       print(mytime.minute)        <- 20
	   print(mytime)               <- 13:20:01.000020 
	   
   - we can set the date:
   ex. 	mydate = datetime.date(1974, 12,20)           <- we can set the date (year, month,day as argument)
		print(datetime.date.today(),datetime.date.today().year,datetime.date.today().month, datetime.date.today().day)   - we can use the date and time modules and functions by importing date time:

   - we can set the date and time :
   ex. from datetime import datetime
		datetime.datetime(2021,10,3,14,20,1)      2021 oct 3, 14:20 and 1 seconds
   
   - datetime.now() we can find out the date and time now:
   ex. import datetime as dt
       now=dt.datetime.now()    <- prints out the date and time in this moment, date.time type of object
   
   - replace: we can replace a field in the date with an updated one:
   ex. mydatetime = datetime.datetime.now()
       mydatetime.replace(year=2020)        changes the year to 2020. same with month and day
	   
   - year: we can find out the year , returning int type:
   ex. now=dt.datetime.now()
       print(now.year)

   - we can find out the minute, second,microsecond:
   ex. now=dt.datetime.now()
	   print(now.minute)
	   print(now.month)
  - we can find the time in ctime format:
  ex. print(today.ctime()               <- "Fri Jun 12 00:00:00 2020"
  - weekday() we can find the day we are 
   ex. dayofweek = now.weekday()           <- returns an integer, monday = 1
   
   - we can create a datetime object with custom date:
   ex. dateofbirth = datetime.datetime(year=1974, month = 12, day =20)  <- we can enter hours, minutes, seconds but not required(onlyyear,month,day)

   - we can format the datetime with the strftime("formatstring")
   ex. x=datetime.datetime(2018,6,6)
       print(x.strftime("%B")   
	  - formatstring: %a - weekday short  Wed
	                  %A - weekday long   Wednesday
					  %w - weekday as a number 0,6, 0 is Sunday
					  %d - day of month 1-31
					  %b - month name short Ian
					  %B - month name long Ianuary
					  %m - month as a number 1-12
					  %Y - year    2018
					  %H - hour 00-23
					  %I - Hour 0-12
					  %p - Am/Pm
					  %M - minute 0-59
					  %S - second 0-59
	
	- we can perform aritmetic on a datetime object:
	ex. from datetime import date
		date1 = date (2020,12,24)
		date2 = date (2021,3,4)
		result = date1 - date2
		print (result.days)
	
	- we can find the difference between 2 datetime objects:
	Ex. datetime1 = datetime(2020,23,3,13,45,23)
	    datetime2 = datetime(2021,3,5,22,34,2)
	    timeelapsed = datetime2-datetime1
		print(timeelapsed.days)            <- prints the elapsed days
		print(timelapsed.hours)            <- prints the elapsed hours

time and timeit module:
----------------------------------------------------------------------
   - we can get time in our code with time from time module:
   ex. import time
       start_time  = time.time()     <- gives time in very small increments
       s = "10"
       print(s)
       end_time = time.time()
       elapsed_time = start_time-end_time
	   
   - we can time small code snippets:
   ex. import timeit
       s = "func(10)"
       z= """def func(n):
	           print(n)
  	   """
	   timeit.timeit(s,z,1000)          <- executes 1000 times the function provided by string s described in  string z

Compressing and decompresing zip files in Python
----------------------------------------------------------------------
   - we can zip  files in python:
   ex. import zip
       with open ("ert.txt",w) as myfile:             <- create new file and write text in it
          myfile.write("this is a text")
	   comp_file = zipfile.ZipFile("compfile.zip","w")                   <- creates an empty zipfile
	   compfile.write(ert.txt", compress_type = zipfile.ZIP_DEFLATED)    <- compress and add file to the zip file 
	   comp_file.close()                                                 <- close file 
       
	- we can unzip files in python:
    ex. import zipfile
        zip_obj = zipfile.ZipFile("comp_file.zip","r")               <- open zipfile in read mode
        zip_obj.extractall("extracted_content"))                     <- it extractsto thesame folder as the zip file in
		
    - we can zip an entire directory with shutil module
	ex. import shutil
	    dir_to_zip = "C:\\Documents\\Myfolder"
		output_filename = "documentsarhive"
		shutil.make_archive(output_filename,"zip", dir_to_zip)      <- zips to output_filename the dir_to_zip folder with compression type "zip" 
		shutil.unpack_archive(example.zip", "final_unzip","zip")    <- it will unzip all the files from example.zip to "final_unzip" folder with the zip compression type
 		
python webbrowser module:
----------------------------------------------------------------------
   ex. import webbrowser
       webbrowser.open("http://www/python.org")
       help(webbrowser)
       print(1, 2, 3, 4, 5, 6, 7, 8, 9, sep='; ')              /kimutatja 1; 2; 3; 4; 5; 6; 7; 8; 9
       chrome=webbrowser.get(using='google-chrome')
       chrome.open_new("http://www/python.org")
	   
running python files in the cloud:
-----------------------------------------------------------------------
   - pythonanywhere.com    <- make an acount
   - in a made directory we upload the project folder to the servers
   - console->bash console->python3 main.py
   - Task menu-> scheduled task -> daily 

Aplication Programming interface (API) in Python:
------------------------------------------------------------------------   
   - we can find a bunch of apis in apilist.fun site
   - some sites have API-s to interact with them
   - it is an interface to comunicate with the external system where it is specified how can we acces the services:
   - we make an API request in the form specified by the interface and we get responses:
   - sites that are offering API's: coinbase, open-notify.org, yahoo, googlemaps, etc
   - the International Spacestation Current Location API returns the lat and long of the space station with a unix timestamp.Needs no inputs
   - we can connect to API's with the request module:
   - the iss api returns a json file with the following structure:
   ex. {
          "message":"succes","timestamp":UNIX_TIMESTAMP,"iss_position":{"latitude":CURRENT_LATITUDE,"longitude":CURRENT_LONGITUDE}
	   }
   - the code that gets this data from the site:
   ex. import requests    <- may need to be installed, most important framework for api developers
       response = requests.get(url="link-of-api-link.json")
	   response.raise_for_status()	    <- returns an error status if something is wrong, None if it is ok
       data = response.json()
		longitude = data ["iss_position"]["longitude"]
		latitude = data ["iss_position"]["latitude"]
	   print(response.status_code) 
	   
   - websites have different response codes: 1xx: Hold on, something is happening
                                             2xx: Here you go, its ok 
											 3xx: You dont have permission
											 4xx: you screwed up(thing not exist)
											 5xx: the server screwed up 
	- apis can get parameters so they responds with something that depends on the parameter sent:
	ex. import requests
	    parameters = {"lat":51.03,"lng":13.34}
	    response = requests.get("http://api.sunrise-sunset.org/json", params=parameters)        <- checks if connection is allright
		response.raise_for_status()          <- will give an exception if we dont provide the parameters needed by the api
		data=response.json()
		sunrise = data["results"][{"sunrise"]
		sunset = data["results"]["sunset"]
		print(sunrise.split("T")[1].split(":")[0])

Api authentication:
---------------------------------------------------------------
   - we can authenticate ourself with api keys to sites that need them with parameter to api call:
   ex. import requests
       Endpoint = "http://api.openweathermap.org/data/2.5/onecall"      
	   api_key="dfgdfggfdgdfgdfgdgdf"
	   weather_params = {"Lat" : 51.3}, "Lon":-0.3, "appid":api_key, }
	   response = requests.get(Endpoint, params=weather_params)            <- http://api.openweathermap.org/data/2.5/onecall?lat=2343432&lon=4535335&appid=dfgdfggfdgdfgdfgdgdf
	   print(response.json())

Api http request:
--------------------------------------------------------------
   - http requests are as follows:
         - requests.get()      <- we ask the external system for a piece of data , and the system response
		 - requests.post()     <- we give the external system some data, response is it was succesfull or not (post data to google sheets)
		 - requests.put()      <- update the external data in the external service
		 - requests.delete()   <- delete an external data on external service

Post request:
---------------------------------------------------------------
   - we can make a post request on pixe.la:
   ex. import requests
       pixelaendpoint="http://pixe.la/v1/users"
       userparams = {
            "token":"tokencode",
			"username":"angela",
			"AgreeTermsofService":"yes",
			"notMinor":"yes",
			}
   	   response=requests.post(uel=pixelaendpoint, json=userparams)
       print(response.text)
	   
    - we can make an authentication 
    ex. userparams = {
            "token":"tokencode",
			"username":"angela",
			"AgreeTermsofService":"yes",
			"notMinor":"yes",
			}
		hders: { "X-USER-TOKEN": TOKEN}
	    graphendpoint= f"{pixelaendpoint}/{USERNAME}/graphs" 
        graphconfig = {"id":"graph", "name":"Cycling Graph","unit":"Km","type":"float","color":"ajisai"}
        response = requests.post(url = graphendpoint, json = graphconfig, headers = hders)		           <- headers = kvargs
	
	- we can post our data and get the response of the server if it succeded or not	
	ex.  pixelcreationendpoint = f"{pixelendpoint}/{username}/graphs/{graphid}"
	     pixeldata = {"date": "20220903","quantity": "9,74",}
		 request.post(url=pixelcreationendpoint, json=pixeldata, headers=hders)
		 print(response.txt)

put request:
--------------------------------------------------------------
   - we can update with the put request:
   ex. updateendpoint=f"{pixelaendpoint}/{username}/graphs/{graphid}/{today.strftime("%Y%m%d")}"
       newpixeldata={"quantity":"4.5",}
       response = request.put (url=updateendpoint, json= newpixeldata, headers=hders)
       print(response.text)
	   
delete request:
--------------------------------------------------------------
   - we can delete from the pixela:
   ex. deleteendpoint=f"{pixelaendpoint}/{username}/graphs/{graphid}/{today.strftime("%Y%m%d")}"
       response=requests.delete(url=deleteendpoint, headers=hders)
       print(response.text)	   
Reading htmlcode:
--------------------------------------------------------------
   - we can read unescaped html code with the html module:
   ex. import html
       extext="this is a &34 day"
	   text = html.unescape(extext)             <- removes the &34
	   
Sending SMS with Twillio:
---------------------------------------------------------------
   - from Twilio.com we can acces the API and send sms (trial account)
   ex. from twilio.rest import Client
       account_sid="sdfsdfSDFSdfsFSD"
       auth_token = "your_auth_token"
	   client = Client(account_sid, auth_token)
	   message = client.messages.create(body = "Hello world", from_="+0040723928287", to="0040756432345")     <- body is the message
	   print (message.status)

Python Anywhere environment variables:
---------------------------------------------------------------
   - when we deploy an aplication to python anywhere sometimes we dont want to change the code, that is why environment variables are handy
   - certain variables used in the code can be used from environment variables that is expected to change in time (email adress, passwords, apikeys,etc)
   - it is a good idea to not store api keys or other confidential data in the code, instead to store it in environment variables in Python anywhere.
     (ex. code is on github, can be seen by others, etc)
   - we can set environment variables in Python Anywhere :
   ex. in console on PythonAnywhere : 
       export variablename=value    <- no space between variablename=value. if it is a string, no "" should be typed
       export apikey=werwr342523rwerr3
	   export name=Tibi
       if we type: env      <- will print all the setted environment variables
   
   - to set in the .py program this variables that will be tacken from the environment:
   ex. import os
       api_key=os.environ.get("apikey")                      <- the api keys are not visible this way
	   name=os.environ.get("name")
	   
   - we can schedule to run variables from the daily task scheduler:
   ex. instead daily at 6am run : python3 main.py  
       we can have run: export name=Tibi; export apikey=ertfsdfs; python3 main.py      <- this method also hides the apikeys and data because it will nt be seen outside
          
Parsing HTML with Beautiful_Soup
-------------------------------------------------------------
   - crummy.com/software/BeautifulSoup/bs4/doc   <- beautiful soup library page
   - www.toscrap.com <- page made for testing scraping
   
   ex. from bs4 import BeautifulSoup
		with open ("website.html") as file:
			contents = file.read()
		soup = BeautifulSoup(contents, "html.parser")
		print(soup.title)              <- <title>Angela's  Personal site</title>
		print(soup.title.string)       <- Angela's  Personal site  (string between the title tag)
		print(soup)                    <- prints out the entire htnl document
		print(soup.prettify())         <- will indent the site 
		print (soup.p)                 <- prints the first paragraph with the included text : <p> This page is under construction</p>
		
	- the soup object is the entire html site file
	
	- select() - we can retrive a page and process it with soup:
	ex. import requests
	    import bs4
	    result = request.get("http://www.example.com")      <- retrives the html from the adress. the result type of data is  requests.models.Request type of object
		print(result.text)                                  <- prints out the html response
		soup = bs4.BeautifulSoup(result.text, "lxml")       <- it converts the data obtained with request to a formateed xml document type ready for processing
		page_element = soup.select("title")                 <- searches through the document for the tags and finds the title tag, returns a list.can be p, body, head, etc
		page_element = soup.select("title")[0].getText()    <- returns the first text between the 2 title tags: <title>This is a title </title>
	
    - we can have different select() queries 
    ex. soup.select("div")         - all elements with "div" tag
        soup.select("#some_id")    - elements containing id = "some_id"
        soup.select(".some_class") - elements containing class = "some_class"
        soup.select ("div_span")   - any element named span within a div element
        soup.select("div>span)	   - any element named span directly within a div element, with nothing in between
	
    - we can download images from site
    ex.import requests
	    import bs4
	    result = request.get("http://www.example.com")
		soup = bs4.BeautifulSoup(result.text, "lxml")
		computer = soup.select(".thumbimage")[0]
		image_link = request.get("http:://image link")
		with open ("image.jpg","wb") as myfile:           <- open the file for binary writing
			myfile.write(image_link)
		
		
Finding and selecting Particular elements with Beautifullsoup
-------------------------------------------------------------
	ex. ex. from bs4 import BeautifulSoup
		with open ("website.html") as file:
			contents = file.read()
		soup = BeautifulSoup(contents, "html.parser")
		allanchortags=soup.find_all(name="a")              <- will find all the html elements with the id <name>
		for tag in allanchortags:
			print(tag.getText())
			
	ex. with open ("website.html") as file:
			contents = file.read()
		soup = BeautifulSoup(contents, "html.parser")
		allanchortags=soup.find_all(name="h1", id="name")             <- <h1 id="name">Attila</h1> this is the html line that looks like a search
		section_heading = soup .find(name="h3", class_="heading")     <- will search for all the h3 that have the class atribute "heading". class_ to diferentiate from the class
		print(section_heading.name)
		print(section_heading.get("class_")                           <- we use class_ instead of class as class is a reserved keyword in python
		cname = soup.select_one(selector="#name")                     <- <h1 id="name">Attila</h1>
		print (name)
		heading = soup.find(name="h1", id="name")
		
Test in Python with pylint:
---------------------------------------------------------------
   - we can run styling teststests on our file (automated) with pylint.exe. it checks if the code is commented, unused variables, function erors, etc
   - to install pylint : pip install pylint
   - to run a test o a file we need to type in a command prompt:
   > pylint myfile.py
   - to write docstrings in python we can write 
   Ex. '''
       This function executes with a variable
	   '''
   
Unit test in Python with Unittest
----------------------------------------------------------------
	- to test a function "myfunc" from a file "myfile.py" we need to create a python script file (mytestfile.py)that imports the file and imports the unittest library
	Ex. import uniitest
	    import myfile
		class TestCap(unittest.TestCase):             <- need to inherit the TestCase from the unittest module
			def test_one_word(self):                  <- test function definition
					testtext = 'python'                <- definition of the input data for the test
					result = myfile.myfunc(testtext)    <- the function under test execution
					self.assertEqual(result,'Python')   <- assert
		if __name__ == "__main__":
			uittest.main()
	
	- to run the test file : >python mytestfile.py
	
	
images in python:
-----------------------------------------------------------------
   - we need to install pillow library to work with images :
   ex. pip install pillow
   
   - we can load an image from the hard drive:
   ex. from PIL import Image
       myimage = Image.open("image.png")
	   print(myimage.size)                  <- displays the image size Horiz/Vert (1900,1240)               
	    print(myimage.filename)             <- displays the files name
		print(myimage.format_description)   <- "jpeg (ISO 10981)"

	- crop() - we can crop images.the (0,0) is top left corner:
	ex. myimage.crop(0,0,100,100)           it crops the image starting from 0.0 to 100,100
	
	- paste() - we can paste an image over an other:
    ex. from PIL import Image
       myimage = Image.open("image.png")
       cropedimage = myimage.crop(0,0,100,100)
	   modifimage = myimage.paste(im = cropedimage, box =(0,0)) 	  <- it pastes the croped image to the original image from pos 0,0
	   modifimage = myimage.paste(cropedimage, box =(0,0,100,200))    <- it pastes the croped image to the original image from pos 0,0 until pos 100,200
	   
	- resize() we can resize an image with the resize function
	ex. myimage.resize((3000,2000))                                    <- it needs a tupple
	
	- rotate() - we can rotate am image with rotate () function
	ex. myimage.rotate(90)               <- rotates the image with 90 degree
	
	- putalpha() - we can add or replaces the alpha layer in an image.if the image does not have an alpha layer it converts to LA or RGBA
	ex. from PIL import Image
	    myImage = Image.open("myimage.jpg")
	    myImage.putalpha(0)                  <- 0 alpha is minimum, 255 alpha is maximum
		

	