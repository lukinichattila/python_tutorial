   
!!!- pythontutor.com
   - 2 types of languages: - interpreted and compiled
     - c, C++ <- compiled
	 - python, java, javascript <- interpreted
   - for finding version: python -v
   - python interpreter is a virtual maschine just like java
   - name convention is a script is a program for an interpreted language
   - one file in a multifile python program is a masterscript that is an entry in the python program(usually main.py but can be any)
   - a python file is level 1 compiled that results in bytecode( *.pyc). The python virtual maschine compiles to maschine code (compilation level 2) that is 
     executed on the processor.C and C++ does not have level 2 compilation that is why is faster then interpreted languages that are 2 level compiled
   - the virtual maschine verifies if a function is called multiple times and caches the maschine code so that it not needs to reintepret it when the 
     function is called again (python does not have this feature, java does(pypy.org python with cache))
   - interpreted languages can change code at runtime, compiled languages not
   - virtual maschine helps achieve platform independence
   - There are utilities that help construct executable programs from python scripts.after compilation makes them platform dependent:
   Ex. py2exe, pyinstaller, py2app, freeze, cx_freeze
   - Jython produces code that runs on Java virtual maschine but can read python code
   - Iron Python can run C# and python scripts together
   - Stackless (not concurent programming - not secvential)
   - in python, identetion is crucial, it makes sense what  comes in which code block. it has 4 space
   - we can write multiple line of code on a single line with ; between them:
   Ex.  l=15;print(l)
   - ASCII - 128 characters
   - UTF-8 standard holds all the language characters for any language(japan, arab,chinese)(used by html, xml,etc)

command line arguments:
---------------------------------------------------------
   - we can use command line arguments with files from sys library:
   ex. import sys                                                      <- acces to command line arguments through sys module
       print (sys.argv)                                                <- the arguments we gave to the .py files in comand line
	   cmd line->python myprogy.py abc 123 "a fost odata"
	   ['myprogy.py','abc','123','a fost odata']                 <- list with all the strings separated by space from the command line arguments
	- sys.argv[0]    - file name 
	- sys.argv[1]    - 'abc'
	- to check if there was an argument given:
	ex. if len(sys.argv)>1
	       print('we have an argument!")
		myargument=argv[1]
    ex. try:
	      myargument=argv[1]
		except:
		   print("we have no arguments!"
		   exit()
	- we can read all the arguments after the filename
	ex. for filename in sys.argv[1:]:   <- all the arguments after the filename

modules in python:
---------------------------------------------------------
   - modules are searched in "sys.path" - it is a list of paths where python library files are located and the current directory
   - PYTHONPATH - environment variable in windows
   
   - we can insert a new path folder in sys.path:
   ex. sys.path.insert(0,'c:/myscript')                  <- sys.path is a list where we can insert elements 
   
   - modules means a file with functions and classes for reuses, package means a group of files, module names start with  lowercase 
   - we can import a *.py file with import
   ex. import hangman
       x=hangman.use()
   
   - we can import a module as an alias and use the alias in front of the functions:
   ex. import hangman as hg                <- hg is an alias for hangman
       a=hg.use()
   
   - we can import just parts of the module with the from keyword - we import just the list:
   ex. happy.py has the folowing variable and function: 
       def greeting():
			print ("Hello")
	   person1=[1,2,3,4]
	   in main.py we have :
	   from happy import person1   
	   print(person1["age"])          <- when importing with from we dont use the modulename when we adress the variable(not happy.person1[age])
	   
   - we can import more things when we import a module:
   ex. from happy import person1 , greeting             person1 is a function, greetig is a variable, if we specify what to import then we dont need to specify 
                                                        library name:
       a=person1(greeting)
   ex. from importable import person as ps
   ex. from importable import (object1,object2)
   ex. from importable import *  
   
   - if we have a file in a subdirectory "librar" we can import it with directoryname.libraryname
   ex. import librar.filename
   
   - we acces something from the library with the libraryfilename.functionname() or libraryfilename.variablename if we didnt import with from lib import variable,func,class
   - we acces somethin from the library with funcname, variable (without libraryname in front) if we import it with "from library import funcname, variable" 
   - when we import something in python, the interpreter executes and creates those elements that we import

packages:
---------------------------------------------------------
   - packages are installed with the pip utility 
   ex. pip command optional
       pip list --outdated
	   pip install <package> --upgrade
	   pip install matplotlib --upgrade
   - tool to manage imported package  http://pypi.org - e repository of 400k open source libraries (search projects)
   - a package is a directory with modules with a file __init__.py
   ex. if we have in a dir Bmp.py, jpeg.py
       use: import Graphics.Bmp
	        image=Graphics.Bmp.load(
   ex. import numpy as np
       numpy. 
	   
Commenting :
---------------------------------------------------------
   - comenting a line starts with #
   # this is a comment
   - we can document the code with """ This class or function does xyz""" under the class name <- when we hover with the mouse over the class name it will display this description

!!!To execute a python program:
----------------------------------------------------------
   - in the command prompt:
   Ex. python main.py                         <- .py is the source code

sleep in python:
----------------------------------------------------------
   - we can have a pause in our program with the sleep function:
   ex. import time
       time.sleep(1)                   <-  stops execution for 1 second
print
----------------------------------------------------------
   Ex. print("casa", 23,32.4)   <- we can use multiple variables separated with ,
       print("Hello 'moni' dear")
   - we can write text multiple lines with \n in the text:
   ex. print("Hello world\nHello world\nhelloworld")                                  <- prints to 3 different line
       l=[2,3,4,2]
	   print(f'nrin ordine={lista}')                                                  <- fstring
   - we can have multiline prints:
     print('''
	    Meniu stringuri:
		1. citeste
		2. scrie''')
   - we can clear the output window:
   ex. from replit import clear
       clear()  
input
----------------------------------------------------------
   - input always results in a string
   - we can enter an object with the input ('message to print')
   Ex. line=input("what is your name?")
       print('Hello',line)
   Ex. print("Helle "+input("what is your name?")) 
   
data types in python and variables
-----------------------------------------------------------
	- function and type names are not reserved words, we can accidentaly override them
	- variable names start with small letters
	- variables are created on the heap
!!!	- every data type is an object in python
    - variables do not need declared with their data type
	- variables come in existence when they are assigned a value, they not need to be declared
	- variables contain a reference to the object they point to (they dont make a copy!!!!!
	- variables can store data of different types	
    - in Python if a variable starts with Big letter, it is considered constant (it is not)
    ex. Number=23	
    - python has the following data types:
        text type: str  
        numeric types: int, float complex
        sequence types: list, tuple, range
        mapping type: dict
        set types: set, frozenset
        boolean types: bool
        binary types: bytes, bytearray, memoryview
	- int  : 5,3,-7                       <- positive or negative numbers, arbitrary large, 0 is the default, without decimals of unlimited length
	- we can represent 123456 as 123_456     <- python knows that _ is for helping us understand large numbers
	- bool : True, False                  <- default is False
	
	- float : 3.141592 (double in c/C++)  <- positive or negative float number, arbitrary large
	Ex. x=3.14
	    x=12E4                            <- scientific notation e power of 10
		
    - complex : complex numbers are writen with a "j" as the imaginary part
	Ex. x=3+5j
	    y=5j
		
	- str 'man', "girl"                   <- strings have default "" empty string
	- Lists
	- user (object data types)
	
!!!	- we can predefine a data type to a variable :
	ex. a:int                <- a will be int, python gives error if assigned differnet type of data type
	
	- type(): we can find the type the data of a variable with the type(var)
	Ex. print(type('type'), type(3))               <- class'str' class 'int'
	
	- variables are asigned values:
	Ex. x=0                     <- x assigned an integer object
	    y='erte'                <- y assigned a string object
	    z=True                  <- z assigned a boolean object
	    print(x,y)
		
   - variable names are not tied to their object type:
   Ex. x=2
       x='trete'    <- x can point to different data type after it was assigned a different data type initialy, 
	   
   - data values that are not pointed to by variables will be destroyed
   Ex. x=2
       x='trete'    <- 2 will be destroyed by garbage collector, no variable points to it
	   y=x          <- values in x will be copied to y
	   
   - we can assign multiple variables multiple values:
   Ex. x,y,z="Luki", "atti", "feri"                 <- multiple definition of variables
   ex. x,y=y,x                                      <- swap numbers
   	   
	- we can convert from float to int:
    Ex. z=23.4
        y=int(z)
		
    - we can convert from int to complex:
	Ex. x=45
	    y=complex(x)
		
    - type(): we can find out the type of a variable:
    Ex. print(type(y))

python dynamic typing:
--------------------------------------------------------------
   - dynamic typing means that after we asssigned a data type to a vaiable, we can assign a different one later:
   ex. a = 5
       print (a)
	   a="text"
	   print (text)
	   
variable scope:
--------------------------------------------------------------
   - variables declared in upper function hierarchyies are visible in lower functions
   - variables declared  in lower function hierarchies are not visible in upper functions
   - in python there is no such thing as block scope
   - if a variable is declared anywhere in a function then it gets function scope 
   - if a variable in a lower hierarchy are declared with the same name with a variable in an upper function , it will overshadow the upper hierarchy variable
   - if we want to use a variable declared in the upper hierarchy we need to declare with global varname     <- not recomended
   - global constants are variable that we declare once and never modify.We declare it with big letters
   ex. PI=3.14
       URL="http:google.com"
   
randomization  in python:
--------------------------------------------------------------
   - random.randint(): we can generate random numbers:           <- we need to import the library
	Ex. import random                           <- imports random module
        n=random.randint(0,22)		            <- generate random numbers between 0 an 22 included
   - random(): we can generate a random number with random() function:
   ex. n=random.random(0,1)                     <- generate a random floatig point number between 0 and 1
   
   - random.choice(): we can return a random element from a list:
   ex. import random
		list=["asda","dfgD","ert"]
		random.choice(mylist)
		
   - shuffle(): we can randomly reorganiza a list with shuffle() method:
   ex. import random
		list=["asda","dfgD","ert"]
		random.shuffle(mylist) 		

strings in python:
----------------------------------------------------------
   - strings are inmutable meaning  we can read the string char by char however we cant change the elements value with string[pos]="c"
   - if we dont have ' in line we can use :
   Ex. print('world')
   
   - we can concatanate strings in python with +
   Ex. first="Luki"
       second="Atti"
       print(first+second)
	   
   - we can step slice a string:
   ex. print(s[0:4:2])    <- prints "hl"
       print(s[0::2])     <- prints "hla"
   
   - we can backwardslice a string:
   ex. print(s[4::-1])       <- prints "anloh"
       print([:-4:-1])       <- prints "loh"    

   - we can use string operators:
   ex. print("Hello"*5)          <- prints  hello hello hello hello hello

   - we can have string replacement fields:
   ex. a="{x}/{y}".format(x=100,y=100)     <- switches x and y with 100 and 100
   ex. print("my age is {0} year and {1} month".format(age, month)}
   ex. print("Nr is {0:2} and squared {1:2}.format(2, 3))            <- :2 with 2 wide
   ex. print("Nr is {0:<2} and squared {1:<2}.format(2, 3))          <- left alligned
   ex. print("Nr is {0:^2} and squared {1:^2}.format(2, 3))          <- center alligned
   ex. print("pi is {0:12.20f}".format(22/7))                             
   
   - we can find the ASCII character code of a character:
   ex. a=ord('a') 

   - we can convert ASCII code to characters:
   ex. print(chr(120))            <- "x"
   
   - if we have a ' in the string we can use the ""
   Ex. print("Worl'd")
   
   - we can have a multiline string:
   ex. s=''' This
             is
			 Sparta '''
	ex. s="""  ez a szoveg
        tobb sorba van irva""" 
			 
   - if we enter 'enter' when input a string, enter is empty string ''
   ex. l=input("enter enter")
       if l=="":
   
   - fstring: we can mix  numbers with strings with the fstring:
   ex. l=f"your score is {var:2}"                                     <- returns a string, var:2
   
   - we can format a float number into string:
   ex. amount = "{:.2f}".format(stringvar)                            <- float to string with 2 decmal precision
   
   - os.path.isdir(): we can check if a string is a directory's name or not:
   Ex. import os
       if os.path.isdir(stringname)
   
   - in: if we want to find if a string in another string we have the in:
   ex. s="eterterte"
       if("er" in s)
	       print("am gasit stringul")
   
   - not in: we can check if a string is not in another string:
   ex. s="eterterte"
       if("er" not in s)
	       print("nu am gasit stringul") 
   
   - len(): we can check the nr of characters in a string with len()
   ex. l=len(stringvar)
   
   - sys.getsizeof(): we can find out the length in bytes of a string with sys.getsizeof()
   ex. import sys
       l=sys.getsizeof(stringvar)
   
   - we can return the elements in a string:
   ex. print("Hello"[0])                         <- H
   
   - lower(): we can change the letters in a string to lowercase with the .lower() function:
   ex. l="sdfere"
       result=l.lower()                                                <- returns a new list with all the letters lowercase leaving the original string intact
	   
   - upper(): we can change the letters in a string to uppercase with the .upper() function:
   ex. l="sDfere"
       result=l.upper()                                                <- <- returns a new list with all the letters uppercase leaving the original string intact

   - swapcase(): we can change the letters from lowercase to uppercase and from uppercase to lowercase with the .swapcase() function
   ex. l="sDfere"
       result=l.swapcase()   
	
   - count(): we can count the number a letter apears in a string:
   ex. l="sDfere"
       print(l.count("e")	   
   ex. l="sDfere"
       print(l.count("e",2)    <- counts from index 2 to the end of the string
   ex. l="sDfere"
       print(l.count("e",2,4)    <- counts from index 2 to index 4 of the string
   
   - strip(""): we can remove spaces or other characters from the begining and end of the string with the strip() function.it returns a copy of the string:
   ex. l=" sDfere "
       x=l.strip()     <- removes whitespace
	   x=l.strip("D")  <- remove "D"
   
   - capitalize(): we can change in a string the first letter to uppercase and the rest to lowercase 
   ex. l="sDfere"
       x=l.capitalize()
   
   - find(): we can find the first occurence of a string in a string with the find() method.it returns the index where it finds it or -1 if not:
   ex. l="sDfere"
       x=l.find('fe')
   ex. l="sDfere"
       x=l.find('fe',2)           <- will return the index of the string searched after index 2
	   
   - isalnum(): we can find if a string has only alfanumeric values with isalnum()
   ex. print(l.isalnum())      <- True or False
   
   - isnumeric(): we can find if a string has only numeric values with isnumeric()
   ex. print(l.isnumeric())      <- True or False
   
   - isalpha(): we can find if in a string is alfabets with the isalpha() method:
   ex. l="sDfere"
       print(l.isalpha())      <- True or False 
	   
   - isdecimal(): we can find if in a string is just decimal values with  isdecimal() method:
   ex. l="sDfere"
       print(l.isdecimal())      <- True or False
	   
   - isdigit(): we can find if in a string is just digits values with  isdigit() method:
   ex. l="sDfere"
       print(l.isdigit())      <- True or False

   - islower(): we can check if a string has all the letters with lowercase with .islower() method:
   ex. l="sDfere"
   print(l.islower())
   
   - isupper(): we can check if a string has all the letters with upercase with .isupper() method:
   ex. l="sDfere"
   print(l.isupper())
   
   - join(): we can join the elements of an iterable with character(or string?) between elements with .join() function
   ex. text = ['Python', 'is', 'a', 'fun', 'programming', 'language']
       print(' '.join(text))                                    <- Python is a fun programming language
 
   - translate(): returns a string where some specified characters are replaced with the character described in a dictionary, or in a mapping table:
   ex. l="sDfere"
       table = l.maketrans("s", "K")
       l.translate(table)               <- table contains the mapping of the character that i will be changed with a character ->KDfere
	   
   - replace(): we can replace a string with an other string with the replace() function:
   ex. l="sDfere"
       replacedtext=l.replace("s", "p")           <- pDfere
   ex. l="sDferestres"
       replacedtext=l.replace("s", "p",2)           <- replaces "s" 2 times with p
	   
   - rfind(): we can find the highest index of the substring in a string. if found, returns index, if not then -1
   ex. l="sDfere"
       str.rfind("sD")

   - rindex(): we can find the highest index  of the substring inside the string . if the substring is not found then exception:
   ex. quote = 'Do small things with great love'
       print(quote.rindex('o small ', 6, 20))	   <- 
   
   - index(): we can find an elements position in the list (first appearence) with the index() function:
     listname.index(value,startelement,finishelement).If element not found then returns ValueError
   ex. l=[1,2,3,4,5,6,7,8]
       a=l.index(3)                             <- 2
     

   - split(): we can split a string in a list of strings , with a separator .split():
   ex. text = 'Python is a fun programming language'
       print(text.split(' '))                                 <- ['Python', 'is', 'a', 'fun', 'programming', 'language']

   - rsplit(): we can split string from the right at the specified separator and returns a list of strings with rsplit().
   ex. text= 'Love thy neighbor'
       print(text.rsplit(". ,"))
	   
   - startswith(): we can check if a strings start with a string with the startswith() method:
   ex. message = 'Python is fun'
       print(message.startswith('Python'))
   ex. message = 'Python is fun'
       print(message.startswith(('Python','is'))               <- searches if the string starts with any element from a tuple
   
   - endsswith(): we can check if a strings ends with a string with the endsswith() method:   
   ex. print(newstring.endswith("string)) 
   
   - title() we can make each word in a string start with uppercase with the title() function:
   ex. text = 'My favorite number is 25.'
       print(text.title())
	   
   - we can add punctuations, digits, whitespaces to a string:
   ex. import string 
       strip=string.whitespace+string.punctuation+string+"\"."

   - a string can be rawstring  - it does not reat /n and other special characters like special:
   ex. b_string=r"this is a \n a string split \t \t ND TABBED"
   
string slicing:
------------------------------------------------------------
   ex. s="abcdefghijklmnopqrstvuwxyz"
       print(s[3])     <- d
	   print(s[-1])    <- z
	   print(s[3:10])	<- defghij     <- range of elements
	   print(s[:9])     <- abcdefghij
	   print(s[1:])     <- bcd....
	   print(s[1:7:2])  <- bdf   <- range with steep
	   print([::-1])    <- reverse iterator from begining to end
	   
conversions:
------------------------------------------------------------
   - we can convert one type to another with they type(variablename)
   Ex. varsta=input("ce varsta ai?")
       b=int(varsta)                     <- converts string to int
	
   - if cannot make conversion then exception "qq" to int exception 
   ex. inercari=10
       msg=f'Ai epuizat toate cele{incercari} incercari'	         <- with f' we convert from int to string
       msg=f'Ai epuizat toate cele{incercari:<20} incercari'         left align with 20 character total (blank if nothing)
   
   - we can convert from int to string:
   ex.l=str(stringvar)
   
   - round(): we can round a float number ( round it to the closest integer)
   ex. s=round(2.342)                <- 2
   
   - we can round it  to decimal places:
   ex. s=round(2.342:2)                        <- 2.34
   
   - if we want to get rid of the decimals in a division we can use //
   ex. s=8//3
   
variable scope:
----------------------------------------------------------
   - variables created outside any function is a global variable
   - global variables can be used inside or outside functions by everyone
   - to change the value of a global variable inside a function we can with the global keyword
   Ex. 
       x=1
	   def func():
          global x                             <- if we dont declare that x refers to the global variable it will create a local variable with name x
		  x=10
		  print (x)
	   func() 

if else:
-----------------------------------------------------------
  - in python the if condition has if - elif - else
  Ex. if rez=="9":                 <- if(rez=="9") works also
        print ('bravo!')
      else:
        print('not 9')	
   Ex. varsta=input("how old are you")
       if int(varsta)<18:                     <- conversion needed because input inputs only string
           print("you are underage")
       else:
           print("you are overaged")	   
   ex. if age<=1:
        print ("age is <=1")
	   elif age==10:
		print("age is 10")
	   elif age==12:
		print("age is 12")
	   else:
	    print ("age not known")
   Ex. numar =4
       if numar >0
          print("nr este poz")
       else:
         if numar<0:
            print("nr este negatic")
     	 else:
            print ("nr este 0")	
   Ex: numar =4
       if numar >0
          print("nr este poz")
       elif numar<0:
            print("nr este negatic")
       else:
            print ("nr este 0")
			
python operators:
------------------------------------------------------------
   - in python the operators are divided in 7 groups
      - arithmetic operators  
	  - assignment operators
	  - comparison operators
	  - logical operators
	  - identity operators
	  - membership operators
	  - bitwise operators
   - Arithmetic operators:
     + - addition - x+y
	 - - subtraction - x-y
	 * - multiplication - x*y
	 / - division - x/y
	 % - modulus - x%y
	 ** - exponential - x**you
	 // - floor division  x//you
   - Assignment operators:
     = - equal - x=5
     += - plus equal - x=x+5
     -= - minus equal - x=x-5
     *= - multiply equal - x=x*5
     /= - division equal - x=x/5
     %= - modulus equal - x=x%3
     //= - floor division equal - x=x//3
     **= - exponential equal - x=x**3
     &= - and equal - x=x&3
     |= - or equal - x=x|3	
   - comparison operators  
     == - equal - x==y
     != - not equal x!=y
	 >,< - greater then, less then - x>y, x<y
	 >= - greater or equal - x>=y
	 <= - less then equal - x<=y
   - logical operators:
     and - true if both are true, else false - x<5 and y<6
	 ex. if a and b
	 or - true if one is true, else false - x<4 or y>3
	 not - true if not - not (x<5 and y<10)
	 ex. if not boolean
   - identity operators
     is - return true if both variables are of same object - x is you
     is not - returns true if both the variables are not the same object - x is not y
     	 
   - membership operator:
     in - returns true if a sequence with the specified value is present in the object - x in y
     not in - returns true if a sequence with a secified value is not present in the object - x not in y
	 Ex. x=["apple","orange"]
	     print("banana" in x)   <- false
		 print("banana" not in x) <- true
   - bitwise operators:
     & - AND - sets each bit to one if both bits are 1
	 ex. c=a&b            <- operator copies a bit to the result if exists in both operands
     | - OR - sets each bit to 1 if one of the bits are 1
	 ex. c=a|b            <- operator copies a bit to the result if exists in in one operands
     ^ - XOR - sets each bit to 1 if only one of the bits is 1
	 ex. c=a^b            <- operator copies a bit to the result if exists in  one and only one operands
     ~ - NOT - invert all bits
	 ex. c=a~b            <- operator copies a bit to the result if exists in  one and only one operands
     << - zero fill left shift - shifts left by pushing zeros in from the right and let the leftmost bits fall of
	 ex. c<<2             <- left shifts with 00000011
     >> - signed right shift - shift right by pushing copies of the leftmost bit in from the left, and let the rightmost bits fall of
	 ex. c=a>>2           <- a is right shifterd with 00000011
	 ~ - complements - reverses the bits 
	 ex. c=~a         <- makes 1 in 0 an 0 in 1

while loop:
-----------------------------------------------------------------
   - executes a block while it is true:
   while cond:
     -code block-
   Ex. suma=0
       nr=1 
       while nr<=1000
         suma+=nr
	     nr+=1
	   print(suma) 

   Ex. suma=0
       nr=1 
       while True
         if nr>1000:
          break	 
         if nr%5==0
           continue
         suma+=nr
         nr+=1
	   print(suma)
	
	- we can have an else: after the while executes it will execute what is in the else:
	ex. while nr<=1000
         suma+=nr
	     nr+=1
	   print(suma) 
	    else:
          return suma	
   - we can use break and continue with while:
    while a<10:
     if a==3:
        continue
     else:
        break	 

for loop:
------------------------------------------------------------------
   - executes a block multiple times
   ex.l=["Atti","Tibi","Shivan","Gauron","Feri"] 
      for element in l:
       print(element)
	   if(cond)
	      break
	   
   ex: for idx in range(len(l)):                                   <- default =0 to len(l)-1     
          print(l[idx])          <- c style array acces notation
   ex. for contor, element in enumerate(list,1):                       <- we have 2 variable incrementing :contor from 0 to n-1, element l[0],l[1],l[2]...l[n-1]
         print(f"{contor:3}. {element}")
   
   - we can loop through a range of numbers:
   ex. for x in range(5):                                            <- by default a range starts from 0 to 5(5 not included)
   ex. for x in range(2,6):                                          <- values 2-5
   ex. for x in range(2,6,3):                                        <- values between 2 and 5 with step of 3
   
   - we can execute code after the for is ended with else::
   ex. for x in range(2,6,3):
			x+=1
	   else:
	      print("hello!")
   
   - we can iterate through a collection with enumerate:
   ex. for count , value in enumerate(list)                        <- count is a counter , and value is the value one at a time from the list
   
   - we can specify a start argument for the enumerate:
   ex. for count , value in enumerate(list, start=3)               <- starts from the 4th element
   
   - we can use continue or break to get out of a loop or restart iteretation with next element:
   ex. for i in a:
         if i==mango:
		    continue
		  else:
		    break
			
   - we can have an empty for loop.we need the pass keyword:
     ex. for a in range:
	        pass
colections:
-----------------------------------------------------------
   - an object with objects
   - elements cant be different type once they are set with a type
   - lists:
      - ordered collection
	  - slow search
   - multimi:
      - unic elements
	  - speed
   - maps:
    - key - value pairs
    - speed
    - unnique keys
   - list - mutable/unmutable	   

python lists:
----------------------------------------------------------
   - list is a collection which is ordered, changeable and allow duplicates elements
   - allows duplicate membership
   - list indices start from 0
   - we can insert different datatypes in it
   ex: l=["edre",1,True,"Erd",3]
   
   - we can point to the same list in memory
   ex. list1=list2                     <- shallow copy
   
   - we can have a copy of a list (diferent memory region):
   ex. list2=list(list1)               <- produce a new list in memory 

   - copy(): we can have a different list, we can do it with copy:
   ex.import copy 
      list2=copy.deepcopy(list)   

   - the list is created placing all the elements inside [ ] separated by commas.first element is always 0
   Ex. list1=["Toni","Zoli","Tibi"]
       print(list[0])     -> "Toni"
	   print(list[1])     -> "Zoli"
	   
   - we can have negative indexing. element [-1] is the last element of the list, [-2] is the before last element
   ex. print(list[-1])   <- "Tibi"
   
   - we can have list with lists:
   Ex. l=[4,'casa',True, [33,12],0]
   
   
range of indexes - list slicing (
----------------------------------------------------------
   - we can specify a range of indexes by specifying where to start and where to end the range
!!!- when specifying a range, the return value will be a new list with the specified items
   - the end range element=end range-1
   ex. list1=["Atti","Tibi","Shivan","Gauron","Feri"]
       print(list1[1:3])                        <- Tibi Shivan  - element 3 not included
   
   - we can specify elements from begining to a set number:
   ex. list1=["Atti","Tibi","Shivan","Gauron","Feri"]
	   print(list1[:3])                                 <- Atti Tibi Shivan <- element 3 not including
	
   - we can specify all the elements from 1 to end:
   ex. list1=["Atti","Tibi","Shivan","Gauron","Feri"]
       print(list1[1:])                                 <- Tibi Shivan Gauron Feri
   
   - we can view elements with negative indexes:
    ex. list1=["Atti","Tibi","Shivan","Gauron","Feri"]
	    print(list[-1:-3])
	  
   - we can specify a range with steps:
    ex. list1=["Atti","Tibi","Shivan","Gauron","Feri"]
	    print(list[1:4:2])     <- Tibi, gauron
		
   - we can have backward list:
   ex. list1=["Atti","Tibi","Shivan","Gauron","Feri"]
       print(list[::-1])            <-  Feri Gauron Shivan Tibi Atti

   - we can specify a range in the for loop with slicing:
   ex. for i in list[1:]:
           print (i)
		   
   - we can make a list with range:
   ex. print(list(range(2,10))        <- makes a list and prints 2,3,..10 
   
   - we can compare 2 ranges:
   ex. range1=range(1,10,2)
	   range2=range(1,10,2)
	   print(range==range2)           <- prints true
	   
   - 

iterators:
----------------------------------------------------------
   ex. string="1234567890"
         my_iterator=iter(string)
         print(next(my_iterator))                    / prints 1
         print(next(my_iterator))                    /prints 2
         for char in iter(string)                     /prints 1 2 3 4 5 6 7 8 9 for char in string   <- implicit iterator in the background
             print (char)
	ex. my_string=["a","b","c","d","e","f","g"]
        iteratorom=iter(my_string)
        for i in range (0, len(my_string)):
            print(next(iteratorom))                            /prints: a b  d e f g
			
working with lists:
----------------------------------------------------------	   
   - we can change the element in the list at a certain position:
   ex. list1=["Atti","Tibi","Shivan","Gauron","Feri"]
       list[1]="Teri"
   
   - for: we can loop through a list with a for loop:
   ex. for i in list1:
          print(i)

   - check if name exists in list with is in:
   ex. list1=["Atti","Tibi","Shivan","Gauron","Feri"]
       if "Tibi" in list:
	      print("Tibi is in the list")
	   else:
	      print("Tibi is not in the list!")
		  
   - sum() we can have the sum of the collection with the sum() function:
   ex. a=sum(iterable, start)
   
   - len(): we can check the length of a list with :
   ex. list1=["Atti","Tibi","Shivan","Gauron","Feri"]
       print (len(list1))
	   
   - append(): we can add a new element to a list with :
   ex. list1=["Atti","Tibi","Shivan","Gauron","Feri"]
       list1.append("Kati")                               <- adds an element to the end of a list
   
   - insert(): we can insert an element to a specified index position with :
   ex. list1=["Atti","Tibi","Shivan","Gauron","Feri"]
       list1.insert(2,"Kati")                             <- "kati" is inserted at postion 2 and all the rest of the elements are moving to the right
	   
   - remove(): we can remove an element by name from the list with :
   ex. list1=["Atti","Tibi","Shivan","Gauron","Feri"]
       list.remove("Tibi")                                <- removes "Tibi" from the list
	   
   - pop(): we can remove the last element from the list with :
   ex. list1=["Atti","Tibi","Shivan","Gauron","Feri"]
       list1.pop()
	   
   - del(): we can delete a list or remove a certain element in a position with :
   ex. list1=["Atti","Tibi","Shivan","Gauron","Feri"]
       del(list1[2])                                       <- removes element 2 of the list
	   del list1[2]	   
	   del(list1)                                          <- deletes list1
	   
   - clear(): we can clear all the elements from a list with :
   ex. list1=["Atti","Tibi","Shivan","Gauron","Feri"]
       list1.clear()                                       <- he list becomes empty
	   
   - copy(): we can make a copy of a list with :
   ex. list1=["Atti","Tibi","Shivan","Gauron","Feri"] 
       list2.copy(list1)                                   <- list 2 will have the elements of list1

   - extend(): we can extend our list (add an other lists elements to the lists end) with the :
   ex. list1=["Atti","Tibi","Shivan","Gauron","Feri"]
       list2=["1","2","3"]
       list1.extend(list2)                                  <- adds element of list2 at the end of list1

   - reverse(): we can reverse the elements of a list with reverse():
   ex. list1=["Atti","Tibi","Shivan","Gauron","Feri"]
       list1.reverse()                                      <- reverses the order of the list

   - sort(): we can sort the list in alfabetical order with sort().In strings Big letter comes before small letter. sorting in place, 
   ex. list1=["Atti","Tibi","Shivan","Gauron","Feri"]
       list1.sort(reverse=True)                             <- reverse is putting the elements in alfabetical order  z-a
	   list1.sort()                                          <- natural ascending sort
   
   - sorted(): if we want the result of the sorting in another variable:
   ex. l=sorted(lista)
   
   - +: we can join 2 list with the + operator:
   ex. list1=["Atti","Tibi","Shivan","Gauron","Feri"]
       list2=["1","2","3"]
	   list3=list1+list2
   
   - list(): we can create a list by using the list constructor:
   ex. list1=list("Atti","Tibi","Shivan","Gauron","Feri")
       print(list1)
   
   - we can acces list in list:
   ex. list1=[["Atti",1],["Tibi",2],["Shivan",3],["Gauron",4],["Feri",5]]
       a=list1[1][1] 	   <- "2"
	   
   - for: we can make a list with a for:
   ex. data(1,2,3,4,5)
       selectitem=[mylist[1] for mylist in data]
	   
   - if we want to find a string in a list:
   ex. l=["wer","dffg","erty"]
       if("wer" in l:                 <- true because wer is an element in language
	   if("w" in l:                   <- false because w is not an element in l(it is part of an element in l)

   - max(): we can found the max value element in a list with the max() function:
   ex. print(max(listname))
   
   - min(): we can find the minimum value in a list with the min function:
   ex. print(min(listname))
   
   - choice(): we ca nreturn a random element from a list:
   ex. import random
		list=["asda","dfgD","ert"]
		random.choice(mylist)
   - shuffle(): we can randomly reorganiza a list with shuffle() method:
   ex. import random
		list=["asda","dfgD","ert"]
		random.shuffle(mylist) 
   - we can check a particular elements index position with the index() function:
   ex. names=[1,3,5,6,2,34,4]
       a=names.index(5)

!!!- count() we can count how many times an element apears in a list:
	ex. names=[1,3,5,6,2,34,4]
	    a=names.count(3)
		
list comprehension:
----------------------------------------------------------
   - syntax:
       newlist = [expression for item in iterable if condition == True]
	   newlist = [expression for item in iterable]
   - we can generate lists with expression in one line of code
   ex. lll=[2*nr for nr in range(1000)]		   <- generates a list where every element is *2
   ex. lll=[ 2*nr for nr in range(1000) if nr%2==0]      <- generate a list with every element to the power of 2 if the elem. is even 
		
tuple:
----------------------------------------------------------
   - a tuple is an ordered container that is not modifiable and accepts duplicates .we cannot add new elements to it after it is created or change the elements
   - we can define a tupel with :
   ex. t=(1,2,3,4)                            <- tuples are created with (), lists with []
       print(t, type(t))
   
   - we can asign tuples to variables :
   ex. t=("1","2","3")
       a,b,c=t          <- a=1,b=2,c=3
	   
   - we can assign variables to tuple of tuples:
   ex. mytuple=(1,"f"),(2,"ty"),(3,"ert")
       a,b,c=mytuple
       number,name=a        <- number=1, name="f"
	   
   - tuple(): we can define a tuple with the tuple constructor:
   ex. thistuple=tuple(("apple","banana"))
   
   - []: we can acces a tuple with []:
   ex. thistuple=tuple(("apple","banana"))
       print(thistuple[1])
   
   - in: we can check if a value tuple is in a tuple:
   ex. thistuple = ("apple", "banana", "cherry")
       if "apple" in thistuple:
   
   - we can make a list from a tuple:
   ex. n = (1,2,3)
       a = list(n)
	   
   - sum() we can have the sum of the collection with the sum() function:
   ex. a=sum(iterable, start)
   
   - we cant change a tuple but can create a list that can change the values, and then convert to a tupple:
   ex. x = ("apple", "banana", "cherry")
       y = list(x)
       y[1] = "kiwi"
       x = tuple(y)
   
   - append(): we cant add new elements to a  tuple by changing i t to a list , adding items then converting to tupple
   ex. thistuple = ("apple", "banana", "cherry")
       y = list(thistuple)
       y.append("orange")
       thistuple = tuple(y)
   
   - remove(): we cant move items from a tuple but can convert to a list, remove and then convert back:
   ex. thistuple = ("apple", "banana", "cherry")
       y = list(thistuple)
       y.remove("apple")
       thistuple = tuple(y)
   
   - del: we can delete the tuple completely:
   ex. thistuple = ("apple", "banana", "cherry")
       del thistuple
	   
   - we can acces a tuple with negative indexing:
   ex. thistuple = ("apple", "banana", "cherry")
       print(thistuple[-1])
	   
   - we can acces a ranged index:
   ex. thistuple = ("apple", "banana", "cherry", "orange", "kiwi", "melon", "mango")
       print(thistuple[2:5])
    
   - we can create a tupple with only one item:
   ex. thistuple = ("apple",)          - we need , after the item
       print(type(thistuple))
	   
   - type(): we can find out the tuples type:
   ex. thistuple = ("apple",)
       print(type(thistuple)
	   
   - we can cycle throu the tuple :
	   for x in t:
	     print (x)
   
   - we can create list of tuples:
   ex. lista=[("gdfg",2),("rtyR",5),("xcvx",4)]
       print(sorted(lista))                        <- it will sort by default after the first element in the pair   
   
   - we can have tuples in lists:
   ex. list[(1,1),(1,2),(3,4)]                                          
       list.append((1,1))
   
   - tuple: we can use the constructor to construct  a tuple:
   thistuple=tuple(("apple", "banana"))
   
   - we can acces tuple in list:
   ex. list1=[("Atti",1),("Tibi",2),("Shivan",3),("Gauron",4),("Feri",5)]
       a=list1[1][1]                               <- "2"
   
   - len(): we can find the tuple's length with len()
   ex. thistuple = ("apple", "banana", "cherry")
		print(len(thistuple))
   
   - we can unpack a tuple:
   ex. fruits = ("apple", "banana", "cherry")
       (green, yellow, red) = fruits

   - If the number of variables is less than the number of values, you can add an * to the variable name and the values will be assigned to the variable as a list:
   ex. fruits = ("apple", "banana", "cherry", "strawberry", "raspberry")
       (green, yellow, *red) = fruits  
   
   - in: we can iterate through a tuple:
   ex. thistuple = ("apple", "banana", "cherry")
       for x in thistuple:
			print(x)
		
   - we can loop through the index of the tuple:
   ex. thistuple = ("apple", "banana", "cherry")
       for i in range(len(thistuple)):
		   print(thistuple[i])
		   
   - we can join 2 tuples:
   ex. tuple1 = ("a", "b" , "c")
       tuple2 = (1, 2, 3)
       tuple3 = tuple1 + tuple2
   
   - if we want to multiply the content of a tuple a given number of times we can use the *:
   ex: fruits = ("apple", "banana", "cherry")
	   mytuple = fruits * 2 

   - count(): we can find how many times an item occurs in a tupple:
   ex: thistuple = (1, 3, 7, 8, 7, 5, 4, 6, 8, 5)
       x = thistuple.count(5)  

   - index(): we can find the first occurence of a value in the tuple:
   ex: x = thistuple.index(8)
 
   - max() - we can return the element with max value from the tuple:
   ex. tuple2 = (1, 2, 3)
       a = max(tuple2)
   - min() - we can return the element with min value from the tuple:
   ex. tuple2 = (1, 2, 3)
       a = min(tuple2)
	   
named tuple:
----------------------------------------------------------
    ex. import collections
        collections.namedtuple()
        ex. t=5,2,7         <- defining
	- we can acces:
	ex. t[0]
	
	ex. Carte.collections.namedtuple("Carte", "titlu autor")         <- it has 2 field one is titlu, one is autor
	    carte2=Carte('Poezii','Lucian Blaga')
		print(carte2.autor)
	Personana.collections.namedtuple("Persoana","nume prenume varsta")
	p1=Persoana("Negru","Maria",33)
	
	
dictionary in python
----------------------------------------------------------
   - key value type of containers of dict type class
   - dictionaries are collection that is ordered, changeable and do not allow duplicates
   - we can define a dictionary as follows:
   ex. thisdict = {"brand":"Ford","model":"Mustang","year":1984}
   ex. d=dict()
   ex. d={} 
   ex, thisdict = {id:"Ford",name:"Mustang",year:1984}            <- id, name,year variables
   ex. thisdict = dict([("id",1984),("name","washer")]}
   ex. thisdict=dict(zip(("id","name","size"),("nr","where","year")  )      <- The zip() function takes iterables , aggregates them in a tuple, and returns it.
                                                                           If 1 iterable, returns list with distinct elements, if different nr of elements then returns a list with nr of tuples that the shortest 
																		   list number of element has
	   print (thedict}                                     <- [("Id","nr"),("name","where"),("size","year")];
   
   - we can have dictionary in dictionary:
   ex. d=dict("France":{"cities visited":["Paris","Lle","Stutgart"])       <- dictionary within a dictionary 
   
   - we can add a new item in the dictionary by using a new key index and assigning a new value to it:
   ex. car = {"brand": "Ford","model": "Mustang","year": 1964}
       x = car.keys()
	   car["color"] = "white"            <- add new element to the dictionary
	
   - we can change an item in the dictionary :
   ex. car = {"brand": "Ford","model": "Mustang","year": 1964}
	   car["brand"] = "Bmw"            <- change element element in the dictionary
	   
   - len(): we can find the length of the dictionary with the len() function:
   ex. print(len(thisdict))    
   
   - we can acces the value of a dictionary with:
   ex. thisdict = {"brand":"Ford","model":"Mustang","year":1984}
       x=thisdict["model"]           <- if key notin dictionary then error
	   x=thisdict.get("model")       <- with get if key is not in dictionary it will not give exception, it returns None
   
   - keys(): we can have a list of all the keys in the dictionary:
   ex. x=thisdict.keys()           <- it is not a new list, it is a view

   - values(): we can have a list of all the values in the dictionary with the value() function:
   ex. x = thisdict.values()        <- it is not a new list, it is a view
   
   - items(): we can have a list of all the key:value pairs as tuples:
   ex. x = thisdict.items()
   
   - in: if we want to find out if a key exist in the dictionary we can with the in keyword:
   ex. car = {"brand": "Ford","model": "Mustang","year": 1964}
       if "model" in car           <- true if "model" is a key
	   
   - update(): we can update the dictionary with the update() method:
   ex. car = {"brand": "Ford","model": "Mustang","year": 1964}
       bike = {"bmx":"medium", "pegas":"small"}
       car.update({"year":1970})
	   car.update(bike)
   - we can join 2 dictionaryes with update():
   ex. fruit={1:"a",2:"b",3:"c"}
       veg={"a":"lemon","b":"aple","c":"orange"}
       veg.update(fruit)
   
   - pop(): we can remove items from the dictionary with pop():
   ex. car = {"brand": "Ford","model": "Mustang","year": 1964}
       car.pop("model")
   
   - popitem(): we can remove the last item of the dictionary:
   ex. car = {"brand": "Ford","model": "Mustang","year": 1964}
       car.popitem()
   
   - del(): we can remove an item with a key name:
   ex. del car["model"]
   
   - we can delete the entire ditionary:
   ex. del car
   
   - clear(): we can clear the dictionary with the clear method, leaving the dictionary empty:
   ex. car.clear()
   
   - for: we can loop with the for through the dictionary:
   ex. for x in car
		print (x)                      <- will print all keys in the dictionary
	
   - we can iterate through all the values in the dictionary:
   ex. for x in car
		print(car[x])
   
   - values(): we can iterate through the values in the dictionary:
   ex. for x in car.values():
		print (x)
		
   - key(): we can use the key() function to iterate through the keys of a dictionary:
   ex. for x in car.keys():
         print(x)
   
   - items(): we can loop through the key:values pair with the items() function
   ex. for x,y in car.items():
		print (x,y)
   
   - copy(): we can copy a dictionary:
   ex. mycar=car.copy()
       mycar=dict(car)
   
   - we can create a dictionary that contains an other dictionary:
   ex. myfamily={"child":{"name":"Emil","year":2004},..}   

   - for: we can acces the items and iterate with for:
   ex. for item in d.items():
		print(item[0], item[1])
   ex. for key,value in d.items()
			print(key,value)
			
   - get() return a value for a given key.If the key is not found then returns None
   ex. fruit={1:"a",2:"b",3:"c"}
       print(fruit.get(3)   

dictionary comprehension:
-----------------------------------------------------------------
   - syntax:
   ex. newdict = {newkey:newvalue for (key,value) in dict.items()}            <- dict.items() are the pair of key values from the dictionaries 
       newdict = {newkey:newvalue for (key,value) in dict.items() if condition True} 
   ex. names = ['Alex","Feri","Tibi"]
       student_score = {student:random:randint(1,100) for student in names}
   
   ex. student_score = {"Alex":24,"Tibi":34,"Feri":12}
       passed_student = {student:scores for (student,score) in student_score.items() if score>=15)   

set in python:
-----------------------------------------------------------------
   - set is unordered, unchangable(just remove and add items) and unindexed, dont allow duplicates, and can be of any type (even mixed)
   - duplicate elements will be ignored
   
   - we can create a set:
   ex. s=set()
       ss={2,2,1,4,5,'casa',True}                     <- set will automatically order the set
   
   - we can create a set from range:
   ex. numbers=set(range(0,10,2))
   
   - we can create a set from list:
   ex. numbers=(4,5,6,7)
       setnumbers=set(numbers) 

   - we can acces items in the set:
   ex. thisset = {"apple", "banana", "cherry"}
	   for i in thisset
          print(i)
   
   - we can search for an item in the set:
   ex. a={"a","b","c","d"}
       if "a" in a
	   
   - sum() we can have the sum of the collection with the su() function:
   ex. a=sum(iterable, start)
   
   - clear(): we can clear a set with clear() method:
   ex. thisset = {"apple", "banana", "cherry"}
	   thisset.clear() 
	   
   - del(): we can delete the set completely:
   ex. thisset = {"apple", "banana", "cherry"}
       del thisset
	   
   - add(): we can add a new element to the set with the add()
   ex. thisset = {"apple", "banana", "cherry"}
	   thisset.add("orange")

   - remove(): we can remove an item,:
	ex. thisset = {"apple", "banana", "cherry"}
        thisset.remove("banana")     <- if the item is not then error
		thisset.discard("banana")    <- if element is not then will not be error
		
   - update(): we can add a set to an other set with update()
   ex. thisset = {"apple", "banana", "cherry"}
       tropical = {"pineapple", "mango", "papaya"}
       thisset.update(tropical)

   - pop(): we can remove the last item with pop()
   ex. thisset = {"apple", "banana", "cherry"}
       x = thisset.pop()                <- because unordered we dont know which is the last element
   
   - sorted(): we can sort the set and put elements in a new container (set cannot be oredered!)
   ex. list=sorted(set)
   
   - type(): we can find the type of a sort with type()
   ex. print(type(set))
   
   - len(): we can find the length of a set:
   ex. thisset = {"apple", "banana", "cherry"}
	   print(len(thisset))
	   
   - split(): we can make a unique collection out of a text:
   ex. import sys
       nume_scrypt=sys.argv[0]           <- name and path of py script
   	   s=set()
	   with open(nume_script,'rt') as file:
		for linie in file:
			cuvinte=linie.split()
			s.union(set(cuvinte))
   
   - we can iterate over a set:
   ex. thisset = {"apple", "banana", "cherry"}
       for x in thisset:
   
   - union(): we can add a set to another set:
   ex. set1 = {"a", "b" , "c"}
       set2 = {1, 2, 3}
       set3 = set1.union(set2) 
   ex. myset.union(set1,set2,..) 
   
   - intersection_update(): we can keep both the duplicates from 2 sets:
   ex. x = {"apple", "banana", "cherry"}
       y = {"google", "microsoft", "apple"}
       x.intersection_update(y)
   
   - differnece_update() remove the items that exists in both sets
   ex. x = {"apple", "banana", "cherry"}
       y = {"google", "microsoft", "apple"}
       x.differnece_update(y)
	   
   - intersection(): returns a set that contains the item that exists in both set x and y:
   ex. x = {"apple", "banana", "cherry"}
       y = {"google", "microsoft", "apple"}
       x.intersection(y)
   
   - symmetric_difference_update(): we can keep all but not the duplicates in 2 sets:
   ex. x = {"apple", "banana", "cherry"}
       y = {"google", "microsoft", "apple"}
       x.symmetric_difference_update(y)
   
   - symmetric_difference(): returns a set that contains all the items from both sets, except items that are presentin both sets:
   ex. x = {"apple", "banana", "cherry"}
       y = {"google", "microsoft", "apple"}
       x.symmetric_difference_update(y)
	   
   - copy(): we can make a copy of a set in another set:
   ex: fruits = {"apple", "banana", "cherry"}
       x = fruits.copy()  

   - difference(): we can find the difference between 2 sets:
   ex. x = {"apple", "banana", "cherry"}
       y = {"google", "microsoft", "apple"}
       z = x.difference(y) 
   
   - isdisjoint(): returns true if no item in set is present in set y:
   ex. x = {"apple", "banana", "cherry"}
       y = {"google", "microsoft", "apple"}
       z = x.isdisjoint(y)	
   
   - issubset(): returns true if all the items in set x is present in set y:
   ex. x = {"apple", "banana", "cherry"}
       y = {"google", "microsoft", "apple"}
       z = x.issubset(y)   
	- issuperset(): returns true if all the items in set y is present in set x:
   ex. x = {"apple", "banana", "cherry"}
       y = {"google", "microsoft", "apple"}
       z = x.issuperset(y)  

    - frozenset(setname)  <- we can make a set inmutable with frozenset:
    ex. frzset = frozenset(setname)	
	   
sorting in python:
-----------------------------------------------------------------
   - we can sort inplace:
   ex. l=[1,2,3,4,5,3,4]           
       l.sort()                  :not create a new list 
   
   - sorted(): we can sort a list and the result is a new list saved in a new variable
   ex. l=[1,2,3,4,5,3,4]
       ll=sorted(l) 
   
   - sorted(): we can sort a list and the result is a new list with custom sorting functions
   ex. l=[1,2,3,4,5,3,4]
       ll=sorted(l, key=fct)                  <- key=fct is a function name of a fucntion  that is used to sort the elements 
       def fct(nr):
			return abs(nr)                    <- returns absolute number for every element in the list
   
   - sorted(): we can sort after a key function:
   ex. l=["Masa","Apa","Birou"]
		ll=sorted(l,key=f),                    
		print(ll)
		def f(string: str):                     <- anotation   type it tells that str is of type string   
			return string.lower()               <- changes all to lowercase and then sort naturally
   
   ex. l=["Masa","Apa","Birou"]
		ll=sorted(l,key=f),                    
		print(ll)
		def f(str):                     <- anotation   type it tells that str is of type string   
			return len(str)             <- it will return the length and then the sorting will happen naturally  after the length
   
   - we can use a lambda function.functions are there to provide a different value after the sorting will sort naturally
   ex. l=["Masa","Apa","Birou"]
		ll=sorted(l,key=lambda s: s.lower()),                    
		print(ll)

    
exceptions:
-----------------------------------------------------------------
   - exceptions is a mechanism to treat errors in programs 
   - it returns values, it has a global variable errno 
   - try block lets test a block for errors
   - except let us handle the error
   - else lets execute code if there is no error
   - finally if specified, will be executed regardless if a block raises an error or not
   - if an exception apears and it is not treated, program will crash
   ex. try:
		 print(x)
	   except:
		 print("An exception occurred")
		 
   ex. while True:
        try:
           x = int(input("Please enter a number: "))
           break
      except ValueError:
          print("Oops!  That was no valid number.  Try again...") 
   ex. linie=input("esti minor?")
       try: 
          varsta=int(linie)                                   <- trys to convert string to int
	   except ValueError as err:
	      print('am prins exceptia',err)                      <- if exception se executa lina asta
   
   ex. try:
         varsta=int(linie)
		 if varsta<18
		    print("esti mnor")
		 else:
		     print("esti major")
	   except ValueError as err:
	     print("am prins exceptia!", err)
		print("!!!!!")
	   except TypeError as err:
	     print("am prins exceptia")
   
   - we can have an else after the try - except with code that is not intended to give exception <- recomended way
   ex. try:
			f=open(arg,'r')
		except OSError:
            print(arg, "has", len(f.readlines()), "lines")
			f.close()
		else:
		   print("yuhuuu!")
   
   - we can have multiple many exceptions to handle an error:
   ex. try:
         print(X)
	   except ValueError:                                   <- ValueError standard python exception from the library
	     print("variable x is not defined!")
	   except TypeError:                                    <- TypeError standard python exception 
	      print("something else went wrong!")
	   else:
	     print("yuhuuu!")
	
	- we can have finally to be executed regardless if there was exception or no:
	ex. try:
         print(X)
	   except NameEror:
	     print("variable x is not defined!")
	   finally: 
		f.close()                  <- closes file 
   
   - we can raise an exception if certain condition occurs:
   ex. x=-1
       if x<0:
	   raise Exception("Sorry, no numbers below zero")
	   
  ex. if x<0:
		raise KeyError("This is a thrown error!")             
   
   - we can define the type of error to raise and the text to print to the user:
   ex. x="hello"
       if not type(x) is int:
	      raise TypeError("Only integers are allowed!")
		  print("Not executed")
   ex. def work():
          raise ValueError('am patit-o!')
	   
	   def f():
		try:
			work()
		except ValueError as err:
			print ("exception caught", err)
	- we have base exception, and any custm exception needs to inherit from BaseException!! 
    
	- error mesages can be catched with the as keyword:
	ex. try:
	        dictionary = {"key":"value"}
			print(dictionary["asda"])
		except KeyError as errormsg:                <- errormsg contains the error message
			print (f"{errormsg}")
			
	- if we can have multiple errors in a try block, it i wise to treat it with a specfic Except error type:
    ex. try:
           file = open("file.txt")
           dictionary={"key":"value"}
           print(dictionary["asd"])
        except FileNotFoundError:	
           print("file not found error catched!
        except KeyError as error_mesage:         
		   print(f"{error_mesage}")

working with files
-------------------------------------------------------------------
   - file acces mode: r - read, a - append, w - write, x - create, t - text mode, b - binary mode
   - open(): we can open a file with the open function: open mode: w - write, r- read, t- text     - more on help
   ex. fileout=open("filename.txt","wt", encoding='asci')                       <- if not pathname then file in same folder, encoding flag optional 
   
   - python processes unicode 16/32, a text file is utf-8 - python traduces to utf-8. if not specified in open then then the standard 
   - if we used the fileout=open syntax, we need mandatory to close the file after we worked with it:
   ex. fileout.close()
   
   - write(): we can write a line to a opened file:
   ex. fileout.write("prima linie!")
   
!!!- the recomended way of opening  and writing a file in python is:   - it closes the file automaticaly!!
   ex. with open ("a.txt", "wt") as fileout:
      fileout.write("prima linie!")
      fileout.write("a doua linie!")
	ex. textlist = ["Dear Name:","I anounce you that i am maried.","see you on my wedding."]
        with open("stas.txt","wt") as inputfile:                                               <- writes the whole text line by line to a file with newline at the end
        for i in textlist:
            inputfile.write(i+"\n")
	
!!!- the recomended way of reading a file in python is:
   ex. with open("a.txt",'rt') as filein:         - r read  t text
           for linie in filein:                            <- the line from the file is read with the new line at the end
              linie=linie.strip()                          <- removes \n from the end of line    
			  lista.append(linie)	

!!!- the recomended  read a file in the memory like a list of multiple lines(file will be closed after use automatically):
   ex. with open ("a.txt") as filein:
         continut=filein.readlines()       <- reads the file line by line and ads it to the  list
         print(continut)		 

!!! the recomended way of writing in a file multiple lines which closes the file automaticaly after usage:
   ex. with open("a.txt",'rt') as filein: 
       filein.writelines(["\nSee you soon!", "\nOver and out."])
	   filein.writelines(listname)   
   
   - we can read a file in the memory like a single line:
   ex. with open ("a.txt") as filein:
         continut=filein.read()       <- reads the file like a long  string
         print(continut)
   
   - we can read from a file line by line and encode in utf8:
   ex. with open('quotes.txt', encoding='utf8') as f:
           for line in f:
				print(line.strip())                        <- strip() removes \n from end of line
		 
   - we can read an undefined number of arguments from the comand line:
   ex. for filename in sys.argv[1:]:   <- all the arguments after the filename
          with open(filename) as fin:
	        
   - we can append to the end of a file:
   ex. varosok=["Temesvar","Arad", "Deva"]
       with open("C:\\Temp\\temp.txt",'a') as varosfile:
       for varos in varosok:
          print(varos,file=varosfile)
		  
   - os.path.isdir(): we can check if a string is a foldername with os.path.isdir()
   ex. import os
      if not os.path.isdir(folderstringname):
          print (f'{folderstringname} is not a foldername!')	   
   
   - isfile(): we can find if the content of a directory list is a file with the isfile():
   ex. for intrare in os.listdir(folder):
			if os.path.isfile(f'{foldername}/{intrare}')                 <- or if os.path.isfile(numelefisieruluicucalea)
				print(intrare)
  ex.file=r'C:\\dir\\file.py'   <- windows style folder notation
     file=r'C:\dir\file.py'                  <- raw it tels the \ sign to njot use as a command characte (\n,\f,\t, etc)
	 file='C:/dir/file.py'
	 path_name=rf'{folder}\{intrare}'
   
   - exists(): we can find out if a file exist or not with exists().if there is no such file, False, else True:
   ex. from os.path import exists
       fileexists=exists(path to file)
   ex. import os.path
       os.path.exists(path to file)
          
   - we can get a files size in bytes:
   ex. import os 
      os.path.getsize(pathwithfilename)
   ex. for intrare in os.listdir(folder):
          path_name =f'{folder}/{intrare}'
		  if(os.path.isfile(path_name):
			size=os.path.getsize(pathname)
			print(f'{contor:3},{intrare:5},{size<6}')
   
   - we can make a list of files with size:
   ex. fisiere[]
       for i in os.listdir(path)
	      path_name -rf'{folder}\{intrare}'
		  if os.path.isfile(path_name)
		  size=os.path.getsize(path_name)
		  fisiere.append((size,intrare))                  <- appends a tuple to the list
		print(fisiere)
		sortate=sorted(fisiere)
		for cnt,t in enumerate(sortate,1):                     enumerate(sortate,1)   <- starts with element 1
		   print(f'{cnt:3},{t[1]:22}, {t[0]:4}')

   - we can delete a file: 
   ex. import os
       os.remove("myfile.txt")
   
   - we can delete a folder:
   ex. import os
       os.rmdir("sample data") 
   
   - we can have relative and absolute paths:
      - relative path:      <- it is relative to the position we are currently
	  	  ./Project/readme.txt    <-  we are going down in the project folder and then we find the file readme.txt
	  - absolute path:      <- it is the absolute pathname
		 d:/This/Project/readme.txt     <- we got absolute path
		 /This/Project/readme.txt        <- in the same drive as the script is in
   - we can go up in directory and then down:
	  - ../../Projet/readme.txt         <- we going up 2 levels and then going down the project folder to the readme.txt
	  
   - in python the current path is the path where we launched the script
   - we can write binary data to a file:
   ex. with open("binary",'bw') as binfile:
       for i in range(17):
         binfile.write(bytes([i])                              /must be converted to binary otherwise error
   - we can read binary data from a file:
   ex. with open("binary",'br')as binfile:
       or b in binfile:
         print(b)
	   
pickle and serialization
------------------------------------------------------------------
   - through serialization we convert from program obiect format to json,xml,etc
   - through deserialization we convert from json, xml, to program obiect format
   
   - we can write objects:
   ex. import pickle
       with open ("db.bin", 'wb') as input                <- open for write as a binary file
	   l=[1,3,'casa']
	   pickle.dump(l,input,pickle.HIGHEST_PROTOCOL)           <- HIGHEST_PROTOCOL compression algoritm to max - first dump in the file
	   pickle.dump('pom',input,pickle.HIGHEST_PROTOCOL)       <- second dump, pom is a string that is dumped in the file after the list l
   
   - we can read objects:
   ex. with open('db.bin','rb') as f:                    <- open for read as a binary file
       a=pickle.load(f)                                  <- every load loads the every dump with write
	   print(a)
	   b=pickle.load(f)                                  <- loads the second dump from the write
	   print(b)
   ex. with open ("file.pickle","rb") as picklefile:
       text2=pickle.load(picklefile)
       album,artist,name, tracklist=text2
       for track in tracklist:
            a=tracklist[0]
            b=tracklist[1]
	
	- we can use json for serialization write - json does save everything in lists so other containers types will be lost 
   ex. import json	
       with open ("db.json", 'wt') as inputfile                <- open for write as a text file forjson
	   mylist=[1,3,'casa']
	   json.dump(mylist,inputfile, indent=4)           <- problem withjosn that is only one dump and we cant dump just 1 object unlike pikle
															indent means it will output it to a more readable format in the file(for eyes)
   - we can use json for deserialization read:
   ex. import json
       with open ("db.json", 'rt') as output
	   l=json.load(output)
	   
   - we can use json to update in a file an already saved json database:
   ex. with open ("data.json", "r") as data_file:
		data=json.load(data_file)
		data.update(new_data)
	   with open ("data.json", "w") as data_file:
	   json.dump(data, data_file,indent = 4)


functions
---------------------------------------------------------------
   - main() is a variable that points to the function main() (just for main function)
   - a function needs to be defined before use
   - argument is the name of the placeholders in the function definition and parameter is the name of data that receives the values when the function is called 
     condition is that it has to be defined before it is called
   - functions called with different numbers of arguments give error
   - a function that returns nothing returns None
   - a functions arguments are references to  the arguments so it can be modifyed and they modifys the passed variables
   - if we dont know how many arguments will be, we add a * in front of argument name
   - in python there is no method overloading
!!!- we can specify the type of the argument a function receives and the return type :
   ex. def func(l: list, index: int) -> int:          -> return type int, arguments are list and int types
   
   - functions can return values: they do with the return variable keyword
   ex. def func(n):
		return n*n*n
   
   - functions can return more values:
   ex. def test2():
		  return 'abc', 100, [0, 1, 2]
	   a, b, c = test2()   
   ex. def funcname (*arg):
         print (arg[2])
   
   - we can call a function with variable number of arguments: the passed argument will be wraped in a tupple, so we can iterate through it:
   ex. def func(*f):                              <- f will be a tupple
		 for i in f
			print(i)
	   func("1","2")

   - we can pass a list or tuple to a function that expects more elements:
   ex. l=[1,2,3]
       def f(a,b,c):
	      print(a,b,c)
	   f(*l)                          <- *l tells python that he needs to unwrap the list to the variables the function expects(l[0]=a,l[1]=b,l[3]=c
	   
   - we can call functions with variable keyword arguments.the argument passes like a dictionary {'name of variable':value} pairs:        
   ex. def funcname(**kid):
            print(kid)
       funcname(name="Tobias",lname="Frank")
	   funcname()
	   funcname(name="Feri")  
	   
   - we can acces the arguments passed like dictionary in the function( unknown number of arguments):
   ex. def funcname(**kwargs):
       for key,value in kwargs.item():
		 print (key,value)
		 print(kwarg[key])
   - ex. def funcname(n, **kwarg):
         funcname(5, car = green, wheels = 4)
		 
   - we can pass a dictionary as a function parameter element by element
   ex. info{'start':0,'stop':1,'step':2}
       def f(start,stop,step):
			print(start,stop,step)
	   f(**info)
   
   - we can pass a tuple and dictionary as function parameters:
   ex. def f(a, *f, **d):                  <- a is mandatory if we have something without a *
		print (a,t,d)                  
       f(1,2,x=88)                          <- 2 will be treated as a tuple, x as a dictionary
   
   - we can use default parameter value - default parameter value is written in the definition of the function
   ex. def myfunc(country="Norway"):                   <- default parameters are defined in function definition
         print(f"I am from {country}")
   
   - we can define a function that does nothing  with a pass
   ex. def myfunc(): pass
   
   - we can pass arguments through name <- keyword arguments are specified when we call the function:
   ex. def numefunctie(a,b,c)
           print(a,b,c)
        numefunctie(c=4,a=3,b=2)          <- c will be in position like c in numefunctie
        numefunctie(2, c=1,b=3)            <- first parameter passing through positional, 2 and 3 through name
		numefunctie(2,c=1,a=3)             <- error , a defined twice     
   
   - a function can be defined in an if:
   ex. a=1;b=4
       if a<3
         def aduna(a,b)
		      return a+b
		print(aduna("sdfs","sdfs"))
   
   - we can exit a function anytime with a return, if return without parameter, then returns "None"
   ex. def func(t):
		print("t")
		return                                     <- function returns None
   
   - we can define our program with a def main():
   ex. def main():                 <- 
       ,.....
	   return
	   main()                      <- execution   
		
   
   - we can define a function folowing way:
   def aduna(a,b)
      return (a+b)      <- indentation important
   
   - we can return multiple things from a function and we can test it:
   ex. def func (a, b)
		if a>b and b not 0
		  return (a+b)
		else
		  return None
   
   - variables  with same name defined global and local in functions, locals will overshadow global. if we tell that glabal keyword, it will acces global
   ex: x=5
       def func(a,b):
	     global x=3
		 return x*(a+b)

   - we can have functions in functions:
   ex. def outer_function(a, b):
		 def inner_function(c, d):
             return c + d
         return inner_function(a, b) 
	   result = outer_function(5, 10)
	   print(result)
	   
!!!- we can exchange the name of the function with an alias and call it:
   ex. def add(d,y):
         return d+y
       mydict={"plus":add}            <- dictionary, add is variablename!!  
       x=mydict["plus"](2,3)               <- mydict["plus"] replaces with the add from the dictionary and becomes the function name!!!!
       print(x)
	   
!!! - we can pass functions to function!!!!:
   ex. def add(a,b,func):
          return func(a,b)
	   def func(a,b):
			return a+b
	   print (add(1,2,func))

   - we can have wrapper function (functions that will be called inside another function):
   ex. def add():
          print ("function")
	   def func(function):
			function()
       func(add)
	
   - we can have default values in the functions:
   ex. def myfunc(a=5,b=6,c=7):
       myfunc(b=7)                           <- the function will take default arguments except b that is given, a and c will be 5 and 7
   ex. def myfunc(a,b=2,c=3)
       myfunc(5)                            <-a=5, rest is default
	   
	- in python overriding method is defining the same name method in the subclass
	- if we want to refer to the super class methodname we can call it with super
	ex. super().metodanem(argument)
	   
lambda functions
------------------------------------------------------------------
   - lambdas are functions defined in the place it is needed
   - lambda functions can take any number of arguments , but can have only one expression
   - syntax :      lambda arguments: expression
   - lambda functions begin with lambda
   - in python a lambda function must be an expression
   ex. lambda s: s.lower()              <- s is an input parameter
   ex. a= lambda a:a+10
       print(a(5)) 

   - we can have multiple arguments in a lambda function:
   ex. x=lambda a,b:a+b
       print(x(1,2))

   - if we have a function that takes an argument and returns a multiplied value of the argument:
    ex. def myfunc(n):
           return lambda a:a*n-1
        mydoubler=myfunc(2)
        print(mydoubler(11))		
	
   - we can have lambda wrapper functions:
   ex. cube=lambda func:func**3
       square=lambda x:x*x
        print("square(cube(2))")
		
   - we can create a lambda function:
   ex. x=lambda a:a+10
       rint(x(5))             <- a==5
   	   
Objects in python:
-----------------------------------------------------------
   - custom abstract data types
   - inheritance and composition
   - polymorfism
   - generic programming(templates in c)
   - exceptions
   - a class inherits by default the "object" class
   - every classs has a method __str__() that is the image of the class in string, inherited from "object" superclass but can be overriden
   - when an object is created the __new__() function is called to find space in memory, then the __init__() to initialize the object
   - functions with __x__ are special dunder functions for suporting python class mechanism:
     __nume__(self,....)
   - __new__() returns the self self pointing reference
!!!- every class has a __init__() function that is inherited from the "object" superclass and is always executed when an object is created(constructor)
     if an object does not have the __init__() then it does not initializes any unitialized data
   - if the __new__ is redefined then object creation is tempered with in exotic way
   - __repr__ and __str__ return a string representation of the class where repr returns it in maschine form and can be reconstructed the class from it.__str__ and repr  can override the defaultfunctions:
   ex. myobject.__repr__()      <- the object representation in a string (variable fields separated by comas)
       m2=eval(repr(myobject))     <- will reconstruct m2 from the objects string representation
   
   - we can define a class with:	 
   ex. class Personana:
         def __str__(self):                  <- method, a function defined in the object superclass, overiden with the same name
		    return "aloha!:
   - we can create a class with no code with pass:
   ex. class people:
          pass
   - we can create a class:
   ex. p1=Persoana()
       print(p1)                 <- it calls the .__str__() function of the object that is inherited from "object" - t returns a string representation 
  
  - we can assign values to variables when we create an object:
   ex. class Person:
		 def __init__(self, name, age):
		    self.name=named
			self.age=age
		def __str__(self)"
			return ("T%his is the class")         <- when print(p1) it will return and print "This is the class"
		 def speak(self)
		    print("{self.name} aloha")
		 
	  p1=Person("John",36)
	  p1.speak()
	  p1.name="Tibi"
	  p1.age=15
      print(p1.__dict__)    <- __dict__ is a dictionary and prints all the elements of the object like a dictionary
	  
!!!- self parameter is a reference to the current instance of the class and is used to acces variables and functions that belong to the class(this in java and c++)
     it does not need to be called self, but needs to be the first parameter of any method of a class
   ex. class Person:
           def __init__(mysillyobject, name, age):
           mysillyobject.name = name
           mysillyobject.age = age
   		   
   - we can acces objects with the object name .variable or function name:
   ex. p1=Person("John",36)
	   p1.speak()            <- Persoana.speak(p1)              <- from this comes the self - p1
	   p1.name="Tibi"         
	   p1.age=15
	- we can have class definition with no content with the pass - we need it because if not then identetion error on next line
   ex. class Person:
        pass   
    - we can redefine the __str_() function to return custom string
	ex. class Person:
		 def __str__(self, name, age):
		    return "f{name} {age}"
constructor:
-----------------------------------------------------------
   - in python the constructor is the __init__() method:
   - we can have parameterized constructors:
   ex. class Person:
		 def __init__(self, name, age):
		    self.name=name               <- declaration and definition , class variables are called atributes
			self.age=age                 <- declaration and definition, class variables are called atributes
		 def speak(self)
		    print("aloha") 
       p1= Person("John",36) 
   def __init__ (self, radius)
    circle=Circle(2)

   - we can have unparameterized constructors:
   ex: class Person:
		 def __init__(self):
		    self.name="Tibi"              <- declaration and definition , class variables are called atributes
			self.age=24        

    - we can have default constructor
	ex. class Student:
	      roll_num=15
		  def display (self)
		     print(self.roll_num)
   
   - we can have multiple constructors in a class:
   ex. class Student:
         def __init__(self):
		       print ("first constructor")
		 def __init__(self):
		       print("the second onstructor")
			   
	- if there are multiple constructors python will always call the last constructor
			 
delete object properties:
-----------------------------------------------------------
   - we can delete object properties:
   ex. class Person:
		 def __init__(self, name, age):   <- metode instanta, overwrite __init__() inherited method from "object"
		    self.name=named              <- declaration and definition 
			self.age=age                 <- declaration and definition
		 def speak(self)
		    print("aloha") 
      p1= Person("John",36)
      del p1.age	                     <- we deleted the properties of the p1 object

object deletion:
-----------------------------------------------------------
   - we can delete an object with del()
   ex. p1= Person("John",36)
       del p1  
	   
Inheritance:
-----------------------------------------------------------
   - in python there are 4 types of inheritance:
      - single inheritance
	  - multilevel inheritance
	  - hierarhical inheritance
	  - multiple inheritance
   - single level inheritance enables a derived class to inherit characteristics from a single class:
   ex. class employee():     <- parent class
          def __init__(self, name,age):
               self.name=named
               self.age=age
       class childemployee(employee):
          def __init__(self, name, age, id):
                self. name=named
                self.age=age
                self.id=id	
    employ=employee("Tibi", 22)
	
   - multi level inheritance enables a derived class to inherit properties from an imediate parent class that inherits from a parent class
   ex. class employee():
         def def __init__(self, name,age):
               self.name=named
               self.age=age
	   class childemployee(employee):
          def __init__(self, name, age, id):
                self. name=named
                self.age=age
                self.id=id 
	   class childemployee2(childemployee)               <- 
	         def __init__(self, name, age, id, salary):
                self. name=named
                self.age=age
                self.id=id 
				self.salary=salary
   
   - hierarchical inheritance enable more then one derived class to inherit properties from a parent class:
   ex. class employee():
         def def __init__(self, name,age):
               self.name=named
               self.age=age
	   class childemployee(employee):
          def __init__(self, name, age, id):
                self. name=named
                self.age=age
                self.id=id 
       	class childemployee2(employee):
          def __init__(self, name, age, id):
                self. name=named
                self.age=age
                self.id=id 
	 childempl1=childemployee("Tibi",22,324)
     childempl2=childemployee2("Feri",21,321)
   
   - multiple level inheritance enables one derived class to inherit properties from more then one base class:
   ex. class employee():
          def def __init__(self, name,age):
               self.name=named
               self.age=age
		class employee2():
          def def __init__(self, name,age):
               self.name=named
               self.age=age
               self.id=id			   
			   
	   class childemployee(employee, employee2):
          def __init__(self, name, age, id):
                self. name=named
                self.age=age
                self.id=id 
				
   - we can inherit an object from another with the (objectname) method
    ex. class Personana(object):             -<- object is the class that is inherited
	- if we write class Person: it means it is not inheriting anyone
   - a class inherits by default the "object" class:
   ex. class Person:
		 def __init__(self, name, age):   <- metode instanta, overwrite __init__() inherited method from "object"
		    self.name=named              <- declaration and definition 
			self.age=age                 <- declaration and definition
		 def speak(self)
		    print("aloha")
			
	  class Student(Persona):
	     pas
   - when a class inherits an other it gets the other classes properties and methods
   
   - we can initialize the parent class when we inherit with the super keyword:
   ex. class Animal:
          def __init__(self):
		         self.num_eyes = 2
		  def breathe(self):
				print("Inhale, exhale")
	   class Fish(Animal):
           def __init__(self):
		       super().__init__()                                  <- the super refers to the super class
		   def swim(self):
		       print("moving the fish")
		   def breathe():
		       super().breathe()                                    <- calls the super classes method
			   print("doing this underwater")
	  nemo = Fish()
	  nemo.swim()
	  nemo.breath()
   
Accessing methods of the objects:
------------------------------------------------------------
   - we can acces a metod of a class with classname.function()
   ex. class Person:
		 def speak(self)
		    print("aloha") 
	   p1 = Person()
	   p1.speak()
	   

Standard built in inheritable methods:
--------------------------------------------------------------
   ex. len(p1)               <- p1.__len__()
        print(p1 is p2)      <- p1.__eq__(p2)           test de egalitate de identitate
    the eq function could look like this:
	def __eq__(self, second):
	    return (self.nume==second.nume and self.varsta==second.varsta)
		
		
   class Circle:
		def __lt__(self, second):              <- defining the less then function like comparison operator
			return self.radius<second.radius
			
        def reportsort:
			return sorted(self)                <- this needs the __lt__ function for sorting to be defined
			form:Shape.Circle                <- anotation, helps python to know what is form
			
polymorphism
------------------------------------------------------------
   - we can have compile time polymorphism: 
    ex. class employee():
       def name(self)
	     print("Tibi is his name)
	   def salary(self)
	     print("his slary is 350")
      class employee2():
        def name(self)
	      print("Zoli is his name)
	    def salary(self)
	      print("his slary is 250")
      def func(obj):
          obj.name()
		  obj.salary()
	
	  objemp=employee()
	  objemp2=employee2()
	  func(objemp)
	  func(objemp2)
	- we can have runtime polymorphism:
	ex. class employee():
          def __init__(self, name,age):
               self.name=name
               self.age=age
          def earn (self):
               pass
        
		class childemployee1(employee):
           def earn(self):    runtime polimoprphism
                print(:no money")
        
		class childemployee2(employee):
           def earn(self):    runtime polimoprphism
                print(:has money")
        c=childemployee1
		c.earn(employee)                     <- acces the function from the parentclass, error if not
		d=childemployee2
		d.earn(employee)                     <- acces the function from the parentclass

Method override:
-----------------------------------------------------
   - we can override methods in the child class naming the method with the same name:
	ex. class Parent():        
			def show(self):
				print("Inside Parent") 
		class Child(Parent):         
			def show(self):
				print("Inside Child")
				
	- we can acces the super class method from the overide method with super() keyword:
	ex. class Parent():        
			def show(self):
				print("Inside Parent") 
		class Child(Parent):         
			def show(self):
				super().show()
				
	- we can acces the super class method from the override method with the name of the parent class:
	ex. class Parent():        
			def show(self):
				print("Inside Parent") 
		class Child(Parent):         
			def show(self):
				Parent.show()                         <- parent class name
				
encapsulation:
-----------------------------------------------------
   - encapsulation means makeing members private
   - we can make a member variable with double __ in front private:
   ex. class maxearn():
         def __init__(self):
		        self.__maxearn=10
	     def earning(self):                        
		     print(f"earning: {self.__maxearn}")
	     def setmaxearn((self, earn):              <- setter method
		     self.__maxearn=earn
			 
abstraction:
------------------------------------------------------
  - we can abstractize the methods of a class with a pass
  - the subclasses needs to implement the parent class abstract method:
  ex. class employee(ABC):
         def emp_id(self, id, name, age):         <- abstraction
		     pass
	  class childemployee(employee)
	     def emp_id(self, id ):                    <- partialy implemented in the child class
		     print("emp_id is ")
			 
math module:
-------------------------------------------------------
   import math
   x=min (15, 10,20)
   x=abs(-7.2)    <- absolute number (it returns the positive number of the number getting rid of the -)
   x=pow(3,4)
   x=math.sqrt(64)
   x=math.floor(z)             <- rounds the number down to an integer i<= z
   
event listeners:
-------------------------------------------------------
   - keyboard event listeners work by passing the key type that will be pressed  and a function that will be triggered when the key was pressed
   
working with CSV files:
--------------------------------------------------------
   - we can easily work with csv files in python by importing the csv module
   ex. import csv
   
   - we can read in a list from a csv file with the csv.reader()
   ex. import csv  
       with open ("file.csv","r") as data file:
	   data = csv.reader(data_file)
	   temperatures = []
	   for row in data:
	      if row[1] != "temp":             <- the first line in the file might be the tablenames
			temperatures.append(row[1])
	   print (temperatures)
	   
pandas:
----------------------------------------------------------
   - we can use the functions in pandas we can import pandas library:
   ex. import pandas                <- we may not have it and needs to be installed
   
   - readcsv() we can read datas from a csv file with pandas.read_csv() function:
   ex. data = pandas. read_csv("filename")                     <- puts all the data in a table with indexpositions(if it was saved), tablenames, etc
   
   - [] we can acces a tablename from the table with the [] or with table.tablename
   ex. print(data["temp"])              <- outputs all the elements of the tablename temp  - dictionary type of adressing
   ex. print(data.temp)                  <- object type of adressing
   
   - we can acces the elements of the elements in a json converted file with the []:
   ex. data["temp"][0]["location"][1:12:2]       <- slice notation from 1 to 12 with step 2
   
   - we can convert a json object to a pandas dataframe:
   ex. from pandas import json_normalize
       mydataFrame = json_normalize(jsonlist)
	   
   - .keys() we can find all the keys of the Dataframe:
   ex. keys = dataframe.keys()
   
   - a panda structure can be 1 dimensional, or 2 dimensional data
      - 1 dimensional are Series
	  - 2 dimensional are DataFrame
   
   - the data type of the panda structure is DataFrame  (list of dictionary kinda)
   ex. data = pandas. read_csv("filename")
       print(type(data))      <- DataFrame object type    
	   
   - the data type of a table from the DataFrame is a Series type of object:( a list kinda)
   ex. print(type(data[1]))                    <- Series type of data
   
   - the pandas library allow to convert a panda to any data type (DataFrame.to_parquet, to_pickle, to_csv, to_hdf, to_sql, to_dict, to_excel, to_json, to_html, to_feather, to_latex, etc)
   
   - to_list() to convert from a panda table column Series, we can with the to-list() method
   ex. print (data["temp"].to_list())                          <- this convert the panda t a list
   
   - pandas have built in math functions for mean, square, largest, median, etc:
   ex. a= data[0].mean()
   
   - if we want to acces all the row  in the Series:
   ex. print(data[data.day == "Monday"])           <- have acces to all the other elements of the row that has Monday in the day column
       print (data[data.temp==data.temp.max()]
	   
   - we can create a DataFrame object with a dictionary as argument:
   ex. data_dict = {"student":["Amy","Feri","Tibi"], "scores:":[76,56,65]}
       data = pandas.DataFrame(data_dict)            <- we create the panda by creating a dataFrame object with a dictionary as argument
	   
   - data.to_csv() we can save our DataFrame to a csv file:
   ex. data.to_csv("new_data.csv", index = False)                 <- new_data.csv file where we want to save the DataFrame index=False                        
                                                                     does not write the index of every line to the file
   
   - len() we can find how many elements are in a result in the DataFrame:
   ex. squirelcount = len(data[data["Primary Fur color"] == "Gray"])     <- all the elements that contains in the Primary Fur color column the gray element
   
   - iloc[] we can acces a row in a DataFrame with the iloc[pos] if dataframe is a list we can acces row and column
   ex. datarow = data.ilok[0]                <- we can acces all the elements of the first dictionary
   ex. datarow= data.ilok[0][1] 
   
   - iterrows() we can iterate over a Pandas DateFrame with iterrows():
   ex. import pandas
       student_dict = dict {"student":["Angela", "Tibi"], score:[15,13]}  
       for (key,value) in student_dict.items():      <- classsic iteration with a for
          print(value)   
       studentdataframe = pandas.DataFrame(student_dict)
	   #loop through rows of a data frame:
	   for (index,rows) in student_data_frame.iterrows():
	       print(rows.student)                           <- or rows["student"]
   - loc() we can add new rows to a DataFrame with the loc function:
   ex. import pandas
       database = pandas.read_csv("birthdays.csv")
       listofnames=[["Test","test@email.com",1961,12,21],["Anna","anna@gmail.com", 2018,10,21],["Andra","gruia@gmail.com",1982,3,24]]
       for i in listofnames:
          database.loc[len(database)]=i
       database.to_csv("birthdays.csv", index=False, header=False)
   - 
       	   
Graphical user interfaces with tkinter:
------------------------------------------------------------------------------
   - we can find tkinter related information on tcl.tk  
  - we can invoke the graphic user interface with tkinter
   ex. import tkinter
       window = tkinter.Tk()         <- invoke the windows creation
	   windows.config(background = "Red")
	   ..............
	   window.mainloop()             <- this has to bee the last line in the program, before it comes al the code
   
   - title() we can set the title of a window with title()
   ex. window=tkinter.Tk()
       window.title("Title of the window")

   - minsize() we can set the minimum size of a window:
   ex. window=tkinter.Tk() 
       window.minsize(width = 500, heigth = 300)
	   
   - we can change the tkinter logo with wm_iconbitmap("logofile.ico")
   ex. window.wm_iconbitmap("myicon.ico")
   
   - pack() the geometry manager organizes widgets in blocks before placing them in the parent widgets
   - syntax:
   ex. widget.pack(pack options)                <- pack options are **kwarg,we have to specify the key value pair
         options : - expand  - when set to tru the widget expand to fill any space that it can fill
		           - fill - Determines whether widgets fill any extra space alocated by the packer.
				     NONE(default), Y fill horizontaly, Y - fill vertically, BOTH - fill X and Y
				   - side - determines which side of the parent widget packs aginst:TOP, BOTTTOM, LEFT, RIGHT
				   
	- we can acces the properties of the widgets in 2 ways:
	   - the dictionary way:
	   ex. mylabel["text"] = "My button"
       - through the config method:
       ex. mylabel.config(text = "new button")
	   
padding in tkinter(making a space around an element or window border where nothing comes:
--------------------------------------------------------------
   ex.window=tkinter.Tk()
       window.config(padx=100,pady=100)            <- safespace from the border of the window 
       label.config(padx=50,pady=20)
	   
Label in tkinter:
-----------------------------------------------------------
   - Label() - we can give a label to the window:
   ex. mylabel = tkinter.Label(text = "I am a label",fg = "#45337" font = ("Arial", 24, "bold"),width=29)    <- fg foreground color, 24 is size 
                                                                                                       <- width makes the widget this width, centering text
	   mylabel.pack(expand = True)
	   
   - we can change the properties anytime of the element with the .config(options)
	   
Buttons with TKinter:
--------------------------------------------------------------
   - we can create a button with tkinter:
   ex.import tkinter
       def functionnametobecalled:
		print("i got clicked")
      mybutton = tkinter.Button(framename,text = "Klick me!", command = functionnametobecalled)             <- command calls the functioname when clicked on it
	  mybutton.pack(anchor = CENTER)                                    <- puts the button in the center of the frame
   - we can change the label after the creation with 
   ex. mybuton.config(text="fgdF")
   
   ex. from tkinter import *
       class MyButtons:
        def --init--(self, rootone):
          frame=Frame(rootone)
          frame.pack()
          self.printbutton=Button(frame,text="Click here", command=self.printmessage)
          self.printbutton.pack()
          self.quitbuttton=Button(frame, text="Exit", command=frame.quit)                         /frame.quit  kimehy a windowbol
          self.quitbutton.pack(side=LEFT)
        def printmessage(self):
          print("Button clicked")
        root=Tk()
        b=MyButtons(root)
        root.mainloop()
		
   - we can change the properties anytime of the element with the .config(options)
   
   - we can put an image on a buton:
   ex. my_image = tkinter.PhotoImage(file = "pathtofile/file.png")
       mybuton = tkinter.Button(Image = my_image, highlighttickness=0)
   
Entry with tkinter:
--------------------------------------------------------------
   - The Entry widget is used to accept single-line text strings from a user.
   - we can have an entry window where we input data:
   ex. import tkinter
       myentry = tkinter.Entry(framename,width = 20)           <- the frame or window where it belongs
	   myentry.pack()                                <- needed to put it on the window, otherwise does not apear
	   
   - we can get the text in the entry with the get function:
   ex. myentry.get()
   
   - we can change the properties anytime of the element with the .config(options)
   - we can hve a blinking cursor in it with the focus() method:
   ex. myentry.focus()
   -.insert(index, text) we can insert a text in the entry that will be in the box(email sign in a email box): index can be 0, END
   ex.myentry.insert(0, "aloha@aloha.com") 
   
   - .delete() we can delete the content of the entry with delete:
   ex. myentry.delete(0,END)                                      <- deletes an entry from index 0 to index END

Text with tkinter:
--------------------------------------------------------------
   - we can define a text box for multiple line entering:
	ex. text = Text(parrentwindowname, height = 5, width = 30)                 <- textbox propertys height and width in character number and lines
	
	- we can put a cursor in the textbox for imediate typing:
	ex. text.focus()                                            <- puts cursor in textbox
    
	- our text can have some text already typed in:
	ex. text.insert(END, "Example of multiline text entry")
	
	- get() we can get the text in the textbox:
	ex. text.get("1,0", END)               <- get the current value in the textbox at line 1, character 0, until the END of the textline
	
	- we can change the properties anytime of the element with the .config(options)
	
spinbox in tkinter:
-----------------------------------------------------------
   - we can have a spinbox
   ex. spinbox = tkinter.Spinbox(parentwindow,from_=0 to=10, width=5, command=spinbox_used)        <- command - a function that is executed
       spinbox.pack()
	   
   - get() we can get the value from a spinbox:
   ex. print(spinbox.get())
   
   - we can change the properties anytime of the element with the .config(options)
   
checkbuton in tkinter:
-----------------------------------------------------------
   - we can have a checkbuton in tkinter
   ex. checkbutton = tkinter.CheckButton(parentwindow, text=="is on?", variable = checkedstate, command = checkbutonused)  <- checkbutonused a function that will be executed
       checkbutton.pack()                                                                                               variable = checkedstate   <- chackedstate is  0 or 1
		  
   - get() we can get the state of the checkbuton with the get ()
   ex. a = checkbutton.get()
   
   - deselect() we can deselect the checkbuttton:
   ex.checkbutton.deselect()
   
   - invoke() we can call this method that does the same action like a user clicked on the checkbutton
   ex. checkbutton.invoke()
   
   - we can change the properties anytime of the element with the .config(options)
   
radiobutton in tkinter:
----------------------------------------------------------
   - we can have a radiobutton in tkinter
   ex. mainwindow = Tk()
		radiostate = tkinter.IntVar(mainwindow)
		radiobutton = tkinter.Radiobutton(mainwindow,text="Option1", value=1, variable = radiostate, command=radio_used)   <-in radiostate will be  saved which button is clicked
       radiobutton2 = tkinter.Radiobutton(mainwindow,text="Option2", value=2, variable = radiostate, command=radio_used)
	   radiobutton.pack(anchor = W)
	   radiobutton2.pack(anchor = W)
	   def radio_used:
			print(radiostate.get())         <- print out which buton is pressed
	   
   - we can get the state of the radio button: 
   ex. print(radiostate.get())
   
   - we can change the properties anytime of the element with the .config(options)
   
Listbox in tkinter:
----------------------------------------------------------
   - we canhave a listbox in tkinter:
   ex. listbox = tkinter.Listbox(masterwindow, height = 4)
       fruits = ["Apple","pear","orange"]
	   for item in fruits:
		listbox.insert(fruits.index(item), item)
	   listbox.bind("<<ListboxSelect>>", listbox_used)
	   listbox.pack()
	- we can change the properties anytime of the element with the .config(options)

Scale in tkinter:
---------------------------------------------------------
   - we can have a scale in tkinter : it returns a value if we release the mouse
   ex. def scaleused(value):
			print(value)
		scale = tkinter.Scale(masterwindow, from_=0, to =100, command=scaleused))   <- scaleused is a function that gets called when used, 
		                                                                         master represents the master window
		scale.pack()
   - we can get the return value of the scale:
   ex. scale.get()
   
   - we can set the scales value:
   ex. scale.set(value)
   
   - we can change the properties anytime of the element with the .config(options)

menus or  dropdowns in tkinter:
---------------------------------------------------------
   ex. from tkinter import *
       def function1:
         print("Menu item clicked")
       root=Tk()
       mymenu=Menu(root)
       root.config(menu=mymenu)      /tells the root windows who is the menu
       submenu=Menu(mymenu)          /tells that the manu has a submenu
       mymenu.add_cascade(label="File", menu=submenu)
       submenu.add_command(label="Project", command=function1)
       submenu.add_command(label="Save", command=function1)
       submenu.add_separator()
       submenu.add_command(label="Save", command=function1)
       newMenu= Menu(mymenu)
       mymenu.add_sascade(label="Edit", menu=newmenu)
       newmenu.add_command(label="Undo", command=function1)
       root.mainloop()
	   
 toolbar in Tkinter:
---------------------------------------------------------
    ex. from tkinter import *
        def function1:
          print("Menu item clicked")
        root=Tk()
        toolbar=Frame(root, bg="pink")
        insertbutton=Button(toolbar, text="Insert Files", command=function1)
        insertbutton.pack(side=Left, padx=2, pady=3)
        printbutton=Button(toolbar, text="print", commmand=function1)
        printbutton.pack(side=LEFT, padx=2,pady=3)
        toolbar.pack(side=TOP, fill=X)
        root.mainloop()

Status bar in tkinter
---------------------------------------------------------
   ex. from tkinter import *
       root=Tk()
       status=Label(root,text="this is a status",bd,1,relief=SUNKEN, ancor=W)            /status bar=label glued to bottom
       status.pack(side=BOTTOM,fill=X)
       root.mainloop()
	   
Menu in tkinter:
--------------------------------------------------------
   - every toplevel window can have only one menu bar
   - we can add a menu in tkinter:
   ex. from tkinter import *
	   mainwindow=Tk()
	   menubar=Menu(mainwindow)                                    <- creates a Menu
	   filemenu=Menu(menubar,tearoff=0)                            <-create a filemenu whos container is menubar, tearoff means no dashed line!!!!
	   filemenu.add_command(label="New", command = newmethod)      <- add elements to the menu
	   filemenu.add_command(label="Open", command = openmethod)
	   filemenu.add_command(label="Save", command = savemethod)
	   filemenu.add_separator()
	   filemenu.add_command(label="Exit", command = mainwindow.quit()
	   menubar.add_cascade(label="File", menu=filemenu, underline=0)     <- add the filemenu and its elements to the manubar container,
	                                                                        underline means it can be accesed with a shortcut, specifies which character in pos to be underlined
	   editmenu=Menu(menubar, tearoff=0)                                <- tearoff means no dashed line (detach menubar) apears in the menu
	   editmenu.add_command(label="Undo", command = undomethod)
	   editmenu.add_command(label="Redo",command = redomethod)
	   menubar.add_cascade(label="Edit",menu=editmenu, underline=0)
	   submenu = Menu(filemenu, tearoff=0)                               <-creates submenu with parent not main manu but the menu where it apears
	   submenu.add_command(label="Color Themes")
	   filemenu.add_cascade(label="Preferences", menu=submenu)           <-add submenu to filemenu and links it to filemenu
	   
tkinter layout managers: pack, place and grid
--------------------------------------------------------
   - just one manager can be used in a program
   - pack manager: packs each of the element next to each other in a logical manner - by default from up to down
        -hard to position something precise
      ex. label.pack(side = "left")      <- packs everything from left to right
   
   - place manager: permits the positioning much more precise of the elements
	  ex. label.place(x=0,y=0)                         <- positions the element at 0,0 position
	  
   - grid manager: positions the element oon a grid.the window is split on rows and columns and positions the elements on the row,column
     coordonates
		ex. mylabel.grid(column=3,row=2,columnspan=2, rowspan = 5, sticky="W")           <-columnspan means how many columns it will stretch
																			  - rowspan means how many rows it will span
               - sticky() we can position inside a grid cell with sticky  
                label.grid(row=10, column=10, sticky="w", padx=10, pady=10)    <- positions to the left side of the grid cell(default is center), 
				                                                                  padx,pady makes spaces in pixals before and after the widget, up or down			   
		
tkinter Canvas widget:
--------------------------------------------------------
   - canvas allows to layer one widget over an other widget
   ex. from tkinter import *
        window= Tk()
		window.title("Hey")
		window.config(width=100,heigth=50, bg = "#e65743",padx=20,pady=20)     <- hexa for the color,padx,pady space where nothing comes
        mycanvas = Canvas(width = 200, heigth = 200,bg="#5467763",highlighttickness=0)      <- width and heigth in pixel
		imagevar = PhotoImage(file="tomato.png")      <- PhotoImage is a tkinter format that can read an image file and return it in python
        myimage = mycanvas.create_image(100,122,image=imagevar)       <- creates an image on the canvas places it to 100,122 with center of the image like anchor
		myimage = mycanvas.create_image(0,0,anchor="nw",image=imagevar)   <- creates an image on the canvas,
                                                                		places it to 0,0 with the uper left corner of the image as anchor
		mmytext = mycanvas.create_text(100,112,text="yuhuuu",fill="white",font=("Arial",35,"bold"), width = 100)      <- fill - color in the background of the text
		mycanvas.pack()                                                                                                  width is the text box width where the text will be fit
		
   - whenever we add something to the canvas, we need to specify position , middle is the position	where x and y are considered
   - itemconfig() we can modify the atributs of any widget placed on a canvas with the itemconfig()	
	ex. mycanvas.itemconfig(mytext, text = "hulla")                      <- mytext is the widget name placed on a canvas, , text is the property changed
	- by default when an image is placed the center of the image is taken when placeing as coordinate
	- to specify  the upperleft corner of the image when placing we can use the anchor():
	ex: self.canvas.create_image(0, 0, image=self.image, anchor="nw")           <- anchor="nw" means that when placing the image the upper left corner shouldbe placed at the coordinates

.after() widget property:
---------------------------------------------------------
   - .after() we can use the .after() property on a widget that waits for an amount of time and then gives a command to execute something:
   ex. import tkinter
       window = tkinter.Tk()
	   timerpause = window.after(1000,dosomething,*args)       <- dosomething is a method name that will be called, *args is an argument list that
                                                 	              will be passed to the function(can be used on main window or any other widget that needs it)
	   def dosomething(a):
			print(a)
   - .after_cancel()we can cancel the timer setup with the cancel method:
   ex. window.after_cancel(timerpause)                         <- timerpause is the variable that the after was assigned
   
messagebox in tkinter:
----------------------------------------------------------
   - messagebox is defined in tkinter:
   ex. import from tkinter messagebox
   
   - the folowing methods are defined in the messagebox class:
           showinfo(title=None, message=None, **options): Show some relevant information to the user.
           showwarning(title=None, message=None, **options): Display the warning to the user.
           showerror(title=None, message=None, **options): Display the error message to the user.
           askquestion(title=None, message=None, **options): Ask question and user has to answered in yes or no.
           askokcancel(title=None, message=None, **options): Confirm the users action regarding some application activity.
           askyesno(title=None, message=None, **options): User can answer in yes or no for some action.
           askretrycancel(title=None, message=None, **options): Ask the user about doing a particular task again or not.
	ex. import from tkinter messagebox
	    istrue = messagebox.askokcancel("write","this will be written.Ok or cancel!")
		if istrue:
		   print ("ok was clicked!")

Frame in python:
----------------------------------------------------------
   - we can create a frame in a window with the frame keyword:
   ex. from tkinter import *
       window = Tk()
	   myframe = Frame(window, height=120, width = 180, bg="#234567", bd=1, relief=FLAT)     <- bd = border depth, relief - it does not have rd dimensional
	   myframe.place(x=0,y=0)                         <- x=0,y=0 is the upper left corner of the main window
       window.mainloop()	   
   ex. window = Tk()
       window.geometry("700x480")
       myframe = Frame(window, height=120, width = 180, bg="#234567", bd=1, relief=FLAT)     
       myframe.place(x=0,y=0)  
       myframe2 = Frame(window, height=120, width = 520, bg="#232267", bd=3, relief=GROOVE)     
       myframe2.place(x=180,y=0) 
       myframe3 = Frame(window, height=360, width = 700, bg="#112267", bd=3, relief=RIDGE)     
       myframe3.place(x=0,y=120)                       
	   mybutton = Button(myframe, height = 2, width=5, text="ok", bd=2, relief=raised)    <- we can place a button over a frame (mainwindow can be window, coordonates are relative to masterwindow
	   mybutton.place(x=20,y=20)
	   window.mainloop()
	   
copying to the clipboard:
----------------------------------------------------------
   - to be able to use we need to install pyperclip.
   ex. import pyperclip
       pyperclip.copy(textstring)     <- copies the text to the clipboard
	   pyperclip.paste()              <- returns the text in the clipboard

   - text is pasteable outside and inside of the python progy
	   
smtplib and python(sending mail from python)
--------------------------------------------------------------------
   - SMTP - Simple Mail Transfer Protocol
   - we can send and receive mail from python with the smtplib:
   - the recomended way of sending mail is the one thaat closes the connection imediately:
   ex. import smtplib
       myemail="luky@gmail.com"
	   with smtplib.SMTP("smtp.google.com") as connection:
		connection.starttls()                         <- makes an ancrypted connection, so if someone intercepts mail , it will be encrypted
       connection.connect("smtp.google.com",465)		<- not necesarily needed?
	   connection.login(login=myemail, password="yyyyyy")
	   connection.sendmail(from_addr=myemail, to_addrs="johny@gmail.com",msg="Subject:Hello!\n\nThis is the message!")
   
   - we can connet the old way (like read and write in a file) with the SMTP()
   ex. import smtplib
       myemail="luky@gmail.com"
	   connection = smtplib.SMTP("smtp.google.com")
	   c  /n/n mesage start, subject: subjecttitle
	   conneection.close()
   
   
   - different providers different smtp servers: gmail:smtp.gmail.com, hotmail:smtp.live.com,yahoo:smtp.mail.yahoo.com
   - some providers(yahoo) need special password(generated in the preferences (app password))
   
python date and time module:
----------------------------------------------------------------------
   - we can use the date and time modules and functions by importing date time:
   ex. import datetime as dt
   
   - datetime.now() we can find out the date and time now:
   ex. now=dt.datetime.now()    <- prints out the date and time in this moment, date.time type of object
   
   - year: we can find out the year , returning int type:
   ex. now=dt.datetime.now()
       print(now.year)

   - we can find out the minute, second,microsecond:
   ex. now=dt.datetime.now()
	   print(now.minute)
	   print(now.month)
  
  - weekday() we can find the day we are 
   ex. dayofweek = now.weekday()           <- returns an integer, monday = 1
   
   - we can create a datetime object with custom date:
   ex. dateofbirth = datetime.datetime(year=1974, month = 12, day =20)  <- we can enter hours, minutes, seconds but not required(onlyyear,month,day)

   - we can format the datetime with the strftime("formatstring")
   ex. x=datetime.datetime(2018,6,6)
       print(x.strftime("%B")   
	  - formatstring: %a - weekday short  Wed
	                  %A - weekday long   Wednesday
					  %w - weekday as a number 0,6, 0 is Sunday
					  %d - day of month 1-31
					  %b - month name short Ian
					  %B - month name long Ianuary
					  %m - month as a number 1-12
					  %Y - year    2018
					  %H - hour 00-23
					  %I - Hour 0-12
					  %p - Am/Pm
					  %M - minute 0-59
					  %S - second 0-59
   
python webbrowser module:
----------------------------------------------------------------------
   ex. import webbrowser
       webbrowser.open("http://www/python.org")
       help(webbrowser)
       print(1, 2, 3, 4, 5, 6, 7, 8, 9, sep='; ')              /kimutatja 1; 2; 3; 4; 5; 6; 7; 8; 9
       chrome=webbrowser.get(using='google-chrome')
       chrome.open_new("http://www/python.org")
	   
running python files in the cloud:
-----------------------------------------------------------------------
   - pythonanywhere.com    <- make an acount
   - in a made directory we upload the project folder to the servers
   - console->bash console->python3 main.py
   - Task menu-> scheduled task -> daily 

Aplication Programming interface (API) in Python:
------------------------------------------------------------------------   
   - we can find a bunch of apis in apilist.fun site
   - some sites have API-s to interact with them
   - it is an interface to comunicate with the external system where it is specified how can we acces the services:
   - we make an API request in the form specified by the interface and we get responses:
   - sites that are offering API's: coinbase, open-notify.org, yahoo, googlemaps, etc
   - the International Spacestation Current Location API returns the lat and long of the space station with a unix timestamp.Needs no inputs
   - we can connect to API's with the request module:
   - the iss api returns a json file with the following structure:
   ex. {
          "message":"succes","timestamp":UNIX_TIMESTAMP,"iss_position":{"latitude":CURRENT_LATITUDE,"longitude":CURRENT_LONGITUDE}
	   }
   - the code that gets this data from the site:
   ex. import requests    <- may need to be installed, most important framework for api developers
       response = requests.get(url="link-of-api-link.json")
	   response.raise_for_status()	    <- returns an error status if something is wrong, None if it is ok
       data = response.json()
		longitude = data ["iss_position"]["longitude"]
		latitude = data ["iss_position"]["latitude"]
	   print(response.status_code) 
	   
   - websites have different response codes: 1xx: Hold on, something is happening
                                             2xx: Here you go, its ok 
											 3xx: You dont have permission
											 4xx: you screwed up(thing not exist)
											 5xx: the server screwed up 
	- apis can get parameters so they responds with something that depends on the parameter sent:
	ex. import requests
	    parameters = {"lat":51.03,"lng":13.34}
	    response = requests.get("http://api.sunrise-sunset.org/json", params=parameters)        <- checks if connection is allright
		response.raise_for_status()          <- will give an exception if we dont provide the parameters needed by the api
		data=response.json()
		sunrise = data["results"][{"sunrise"]
		sunset = data["results"]["sunset"]
		print(sunrise.split("T")[1].split(":")[0])

Api authentication:
---------------------------------------------------------------
   - we can authenticate ourself with api keys to sites that need them with parameter to api call:
   ex. import requests
       Endpoint = "http://api.openweathermap.org/data/2.5/onecall"      
	   api_key="dfgdfggfdgdfgdfgdgdf"
	   weather_params = {"Lat" : 51.3}, "Lon":-0.3, "appid":api_key, }
	   response = requests.get(Endpoint, params=weather_params)            <- http://api.openweathermap.org/data/2.5/onecall?lat=2343432&lon=4535335&appid=dfgdfggfdgdfgdfgdgdf
	   print(response.json())

Api http request:
--------------------------------------------------------------
   - http requests are as follows:
         - requests.get()      <- we ask the external system for a piece of data , and the system response
		 - requests.post()     <- we give the external system some data, response is it was succesfull or not (post data to google sheets)
		 - requests.put()      <- update the external data in the external service
		 - requests.delete()   <- delete an external data on external service

Post request:
---------------------------------------------------------------
   - we can make a post request on pixe.la:
   ex. import requests
       pixelaendpoint="http://pixe.la/v1/users"
       userparams = {
            "token":"tokencode",
			"username":"angela",
			"AgreeTermsofService":"yes",
			"notMinor":"yes",
			}
   	   response=requests.post(uel=pixelaendpoint, json=userparams)
       print(response.text)
	   
    - we can make an authentication 
    ex. userparams = {
            "token":"tokencode",
			"username":"angela",
			"AgreeTermsofService":"yes",
			"notMinor":"yes",
			}
		hders: { "X-USER-TOKEN": TOKEN}
	    graphendpoint= f"{pixelaendpoint}/{USERNAME}/graphs" 
        graphconfig = {"id":"graph", "name":"Cycling Graph","unit":"Km","type":"float","color":"ajisai"}
        response = requests.post(url = graphendpoint, json = graphconfig, headers = hders)		           <- headers = kvargs
	
	- we can post our data and get the response of the server if it succeded or not	
	ex.  pixelcreationendpoint = f"{pixelendpoint}/{username}/graphs/{graphid}"
	     pixeldata = {"date": "20220903","quantity": "9,74",}
		 request.post(url=pixelcreationendpoint, json=pixeldata, headers=hders)
		 print(response.txt)

put request:
--------------------------------------------------------------
   - we can update with the put request:
   ex. updateendpoint=f"{pixelaendpoint}/{username}/graphs/{graphid}/{today.strftime("%Y%m%d")}"
       newpixeldata={"quantity":"4.5",}
       response = request.put (url=updateendpoint, json= newpixeldata, headers=hders)
       print(response.text)
	   
delte request:
--------------------------------------------------------------
   - we can delete from the pixela:
   ex. deleteendpoint=f"{pixelaendpoint}/{username}/graphs/{graphid}/{today.strftime("%Y%m%d")}"
       response=requests.delete(url=deleteendpoint, headers=hders)
       print(response.text)	   
Reading htmlcode:
--------------------------------------------------------------
   - we can read unescaped html code with the html module:
   ex. import html
       extext="this is a &34 day"
	   text = html.unescape(extext)             <- removes the &34
	   
Sending SMS with Twillio:
---------------------------------------------------------------
   - from Twilio.com we can acces the API and send sms (trial account)
   ex. from twilio.rest import Client
       account_sid="sdfsdfSDFSdfsFSD"
       auth_token = "your_auth_token"
	   client = Client(account_sid, auth_token)
	   message = client.messages.create(body = "Hello world", from_="+0040723928287", to="0040756432345")     <- body is the message
	   print (message.status)

Python Anywhere environment variables:
---------------------------------------------------------------
   - when we deploy an aplication to python anywhere sometimes we dont want to change the code, that is why environment variables are handy
   - certain variables used in the code can be used from environment variables that is expected to change in time (email adress, passwords, apikeys,etc)
   - it is a good idea to not store api keys or other confidential data in the code, instead to store it in environment variables in Python anywhere.
     (ex. code is on github, can be seen by others, etc)
   - we can set environment variables in Python Anywhere :
   ex. in console on PythonAnywhere : 
       export variablename=value    <- no space between variablename=value. if it is a string, no "" should be typed
       export apikey=werwr342523rwerr3
	   export name=Tibi
       if we type: env      <- will print all the setted environment variables
   
   - to set in the .py program this variables that will be tacken from the environment:
   ex. import os
       api_key=os.environ.get("apikey")                      <- the api keys are not visible this way
	   name=os.environ.get("name")
	   
   - we can schedule to run variables from the daily task scheduler:
   ex. instead daily at 6am run : python3 main.py  
       we can have run: export name=Tibi; export apikey=ertfsdfs; python3 main.py      <- this method also hides the apikeys and data because it will nt be seen outside
          
Parsing HTML with Beautiful_Soup
-------------------------------------------------------------
   - crummy.com/software/BeautifulSoup/bs4/doc   <- beautiful soup library page
   ex. from bs4 import BeautifulSoup
		with open ("website.html") as file:
			contents = file.read()
		soup = BeautifulSoup(contents, "html.parser")
		print(soup.title)              <- <title>Angela's  Personal site</title>
		print(soup.title.string)       <- Angela's  Personal site  (string between the title tag)
		print(soup)                    <- prints out the entire htnl document
		print(soup.prettify())         <- will indent the site 
		print (soup.p)                 <- prints the first paragraph with the included text : <p> This page is under construction</p>
		
	- the soup object is the entire html site file
	
Finding and selecting Particular elements with Beautifullsoup
-------------------------------------------------------------
	ex. ex. from bs4 import BeautifulSoup
		with open ("website.html") as file:
			contents = file.read()
		soup = BeautifulSoup(contents, "html.parser")
		allanchortags=soup.find_all(name="a")              <- will find all the html elements with the id <name>
		for tag in allanchortags:
			print(tag.getText())
			
	ex. with open ("website.html") as file:
			contents = file.read()
		soup = BeautifulSoup(contents, "html.parser")
		allanchortags=soup.find_all(name="h1", id="name")             <- <h1 id="name">Attila</h1> this is the html line that looks like a search
		section_headinf = soup .find(name="h3", class_="heading")     <- will search for all the h3 that have the class atribute "heading". class_ to diferentiate from the class
		print(section_heading.name)
		print(section_heading.get("class_")
		cname = soup.select_one(selector="#name")                     <- <h1 id="name">Attila</h1>
		print (name)